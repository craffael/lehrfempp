/**
 * @file
 * @brief Defines a simple timer class which can be used to measure execution
 * time of a piece of code.
 * @author Raffael Casagrande
 * @date   2020-10-30 12:49:54
 * @copyright MIT License, Boost Software License
 */

// clang-format off
//
// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// clang-format on

#ifndef INCG_529e391f2915453388028b848b3dcbd6
#define INCG_529e391f2915453388028b848b3dcbd6

#include <spdlog/logger.h>

#include <chrono>
#include <cstdint>
#include <memory>
#include <string>
#include <variant>

#include "lf_assert.h"

namespace lf::base {

/**
 * @brief Timer class to measure time
 *
 * @note This class is very similar to the
 *       [boost::cpu_timer](https://www.boost.org/doc/libs/1_74_0/libs/timer/doc/cpu_timers.html#Class-cpu_timer)
 *       class.
 *
 * @see AutoTimer
 * @see
 * [boost::cpu_timer](https://www.boost.org/doc/libs/1_74_0/libs/timer/doc/cpu_timers.html#Class-cpu_timer)
 */
class Timer {
 public:
  /**
   * @brief Packages the elapsed wall clock time, user process CPU time, and
   * system process CPU time.
   */
  struct cpu_times {
    /**
     * @brief Elapsed WallClock time in nano-seconds
     *
     * Wall clock time is time as would be measured by an ordinary wristwatch or
     * clock on the wall.
     */
    std::chrono::nanoseconds wall;
    /**
     * @brief Elapsed User time in nano-seconds
     *
     * User process time is "the CPU time charged for the execution of user
     * instructions of the calling process. It can be higher than wall clock
     * time in multithreaded code.
     */
    std::chrono::nanoseconds user;
    /**
     * @brief Elapsed System time in nano-seconds
     *
     * System process time is "the CPU time charged for execution by the system
     * on behalf of the calling process. In multithreaded code, system time can
     * be higher than wall clock time.
     */
    std::chrono::nanoseconds system;
  };

  /**
   * @brief Construct a new timer and optionally start it immediately.
   * @param start If set to true, the timer will start immediately. Otherwise it
   * will stay in status stopped.
   */
  explicit Timer(bool start = true) noexcept : times_() {
    if (start) {
      Start();
    } else {
      times_ =
          cpu_times{std::chrono::nanoseconds(0), std::chrono::nanoseconds(0),
                    std::chrono::nanoseconds(0)};
      is_stopped_ = true;
    }
  }

  /**
   * @brief Is the timer currently stopped?
   */
  [[nodiscard]] bool IsStopped() const noexcept { return is_stopped_; }

  /**
   * @brief Elapsed time since timer start, doesn't stop the timer.
   */
  [[nodiscard]] cpu_times Elapsed() const noexcept;

  /**
   * @brief Return the number of elapsed seconds of the wall clock time, user
   * time and system time as a formatted string.
   * @param format The [fmt](https://fmt.dev/latest/api.html#core-api) format
   * string that is used to format the output. See below for possible fmt
   * arguments.
   * @return The formatted string
   *
   * #### format named arguments:
   * The following named arguments can appear in the `format` parameter:
   *
   * name | replacement value
   * -----|--------------------------------------
   * `w`  | `Elapsed().wall`
   * `u`  | `Elapsed().user`
   * `s`  | `Elapsed().system`
   * `t`  | `Elapsed().user + Elapsed().system`
   * `p`  | `(Elapsed().user + Elapsed().system)/Elapsed().wall*100.`
   */
  [[nodiscard]] std::string Format(
      std::string_view format = kDefaultFormat) const;

  /**
   * @brief (Re)starts the timer, i.e. the timer starts counting from 0 when
   * this method is called.
   */
  void Start() noexcept;

  /**
   * @brief stop the timer, stop counting the elapsed time.
   */
  void Stop() noexcept;

  /**
   * @brief Resume the timer, i.e. start counting from where we stopped the last
   * time.
   */
  void Resume() noexcept;

  /**
   * @brief Default format string that is used by Format()
   */
  inline static std::string kDefaultFormat =
      "{w:.6}s wall, {u:.6}s user + {s:.6}s system = {t:.6}s CPU ({p:.3}%)";

 private:
  cpu_times times_;
  bool is_stopped_;
};

/**
 * @brief Measures execution time between construction and destruction.
 * AutoTimer can output either to a `std::ostream` or to a `spdlog::logger`
 *
 * This class is very useful when you want to measure the execution time of a
 * particular piece of code:
 * @snippet timer.cc AutoTimer
 *
 * @sa Timer
 */
class AutoTimer {
 public:
  /**
   * @brief Create a new AutoTimer that will report time measurements to
   * `std::cout` when destructed
   * @param format Optional format string that specifies how the measured
   * execution time is printed. See Timer::Format().
   */
  explicit AutoTimer(std::string format = Timer::kDefaultFormat);

  /**
   * @brief Create a new AutoTimer that will report to the given stream during
   * destruction.
   * @param stream The stream to which output should be written.
   * @param format Optional format string that specifies how the measured
   * execution time is printed. See Timer::Format().
   */
  explicit AutoTimer(std::ostream& stream,
                     std::string format = Timer::kDefaultFormat);

  /**
   * @brief Create a new AutoTimer that will report to the given
   * `spdlog::logger` on destruction.
   * @param logger The spdlog logger object to which the timer should write. See
   * \ref loggers .
   * @param level The logging level at which the message will be logged.
   * @param format Optional format string that specifies how the measured
   * execution time is printed. See Timer::Format().
   */
  explicit AutoTimer(
      std::shared_ptr<spdlog::logger> logger,
      spdlog::level::level_enum level = spdlog::level::level_enum::info,
      std::string format = Timer::kDefaultFormat);

  AutoTimer(const AutoTimer&) = default;
  AutoTimer(AutoTimer&&) = default;
  AutoTimer& operator=(const AutoTimer&) = default;
  AutoTimer& operator=(AutoTimer&&) = default;

  /**
   * @brief Destructor of AutoTimer, calls Report().
   */
  ~AutoTimer();

  /**
   * @brief Retrieve the output stream object that was passed in the
   * constructor.
   * @throws std::bad_variant_access if a `spdlog::logger` was passed in the
   * constructor.
   */
  [[nodiscard]] std::ostream& ostream() const;

  /**
   * @brief Retrieve the logger that was passed in the constructor
   * @throws std::bad_variant_access if a `std::ostream` was passed in the
   * constructor.
   */
  [[nodiscard]] const std::shared_ptr<spdlog::logger>& logger() const;

  /**
   * @brief Retrieve the format string that was passed in the constructor.
   */
  [[nodiscard]] const std::string& FormatString() const;

  /**
   * @brief Report time (wall, user, system) since construction of AutoTimer()
   * to either a `std::ostream` or `spdlog::logger` that was passed in the
   * constructor.
   *
   * @note When the output is written to a `std::ostream`, this method will
   * insert an additional newline character at the end.
   */
  void Report();

  /**
   * @brief Retrieve the elapsed time since the construction.
   * @sa Timer::Elapsed()
   */
  [[nodiscard]] Timer::cpu_times Elapsed() const noexcept;

  /// @copydoc Timer::Format()
  [[nodiscard]] std::string Format(
      std::string_view format = Timer::kDefaultFormat) const;

 private:
  Timer timer_;
  std::string format_;

  // ostream is stored as pointer so assignment operator works.
  std::variant<std::ostream*, std::pair<std::shared_ptr<spdlog::logger>,
                                        spdlog::level::level_enum>>
      output_;
};

}  // namespace lf::base

#endif  // INCG_529e391f2915453388028b848b3dcbd6
