#include <gtest/gtest.h>
#include <whitney_one_hodge_laplacian.h>
#include <whitney_two_hodge_laplacian.h>
#include <whitney_zero_hodge_laplacian.h>

#include <array>
#include <cmath>

/**
 *
 * @brief Test the zero hodge laplacian
 *
 * The test tests the discretiation of the Element Matrix for
 *
 * @f[
 *   \Delta_0 \\
 *   f = 0
 * @f]
 *
 * On the Octaeder with radius 1
 *
 * But not the solution of the system is tested only the buildingblocks
 * that is, only the galerkin matrix and the load vector
 *
 */
TEST(projects_hldo_sphere_discretization,
     whitney_zero_hodge_laplace_basic_test) {
  // Build LSE
  projects::hldo_sphere::discretization::WhitneyZeroHodgeLaplace lse_builder;
  lse_builder.Compute();

  Eigen::SparseMatrix<double> Ae = lse_builder.GetGalerkinMatrix().makeSparse();

  Eigen::MatrixXd Ae_anal(6, 6);
  // clang-format off
  Ae_anal <<     8, -2, -2, -2, -2,  0,
                -2,  8, -2,  0, -2, -2,  
                -2, -2,  8, -2,  0, -2,  
                -2,  0, -2,  8, -2, -2,  
                -2, -2,  0, -2,  8, -2,
                 0, -2, -2, -2, -2,  8;
  // clang-format on
  Ae_anal *= 1. / 2. / std::sqrt(3);
  // Assert that the two matrices are approximately equal
  ASSERT_EQ(Ae.rows(), Ae_anal.rows());
  ASSERT_EQ(Ae.cols(), Ae_anal.cols());
  for (int i = 0; i < Ae_anal.rows(); ++i) {
    for (int j = 0; j < Ae_anal.cols(); ++j) {
      EXPECT_DOUBLE_EQ(Ae.coeff(i, j), Ae_anal(i, j))
          << "mismatch in entry (" << i << ", " << j << ")";
    }
  }

  Eigen::VectorXd Vec = lse_builder.GetLoadVector();
  Eigen::VectorXd Vec_anal(6);
  // clang-format off
  Vec_anal <<     0, 0, 0, 0, 0,  0;
  // clang-format on

  for (int j = 0; j < Ae_anal.cols(); ++j) {
    EXPECT_DOUBLE_EQ(Vec(j), Vec_anal(j)) << "mismatch in entry (" << j << ")";
  }
}

/**
 *
 * @brief Test the zero hodge laplacian
 *
 * The test tests the discretiation of the Element Matrix for
 *
 * @f[
 *   \Delta_0 \\
 *   f = 100^2 (Cos[z] + Sin[x] + Sin[y]) + (1/( x^2 + y^2 + z^2))(2 x Cos[x] +
 * 2 y Cos[y] + x^2 Cos[z] + y^2 Cos[z] + y^2 Sin[x] + z^2 Sin[x] + x^2 Sin[y] +
 * z^2 Sin[y] - 2 z Sin[z])
 * @f]
 *
 * On the Octaeder with radius 1
 *
 * But not the solution of the system is tested only the buildingblocks
 * that is, only the galerkin matrix and the load vector
 *
 */
TEST(projects_hldo_sphere_discretization,
     whitney_zero_hodge_laplace_load_test) {
  // Build LSE
  // righthandside for the zero and two form
  projects::hldo_sphere::discretization::WhitneyZeroHodgeLaplace lse_builder;
  auto f = [](const Eigen::Vector3d& x_vec) -> double {
    auto Power = [](double a, double b) -> double { return pow(a, b); };
    auto Cos = [](double a) -> double { return cos(a); };
    auto Sin = [](double a) -> double { return sin(a); };
    // first scale to the circle
    Eigen::Vector3d x_ = x_vec / x_vec.norm();
    double x = x_(0);
    double y = x_(1);
    double z = x_(2);

    // autogenerated by mathematica
    double ret =
        Power(100, 2) * (Cos(z) + Sin(x) + Sin(y)) +
        (2 * x * Cos(x) + 2 * y * Cos(y) + Power(x, 2) * Cos(z) +
         Power(y, 2) * Cos(z) + Power(y, 2) * Sin(x) + Power(z, 2) * Sin(x) +
         Power(x, 2) * Sin(y) + Power(z, 2) * Sin(y) - 2 * z * Sin(z)) /
            (Power(x, 2) + Power(y, 2) + Power(z, 2));

    return ret;
  };
  std::function<double(const Eigen::Matrix<double, 3, 1>&)> f0_ = f;
  lse_builder.SetLoadFunction(f0_);
  lse_builder.Compute();

  Eigen::SparseMatrix<double> Ae = lse_builder.GetGalerkinMatrix().makeSparse();

  Eigen::MatrixXd Ae_anal(6, 6);
  // clang-format off
  Ae_anal <<     8, -2, -2, -2, -2,  0,
                -2,  8, -2,  0, -2, -2,  
                -2, -2,  8, -2,  0, -2,  
                -2,  0, -2,  8, -2, -2,  
                -2, -2,  0, -2,  8, -2,
                 0, -2, -2, -2, -2,  8;
  // clang-format on
  Ae_anal *= 1. / 2. / std::sqrt(3);
  // Assert that the two matrices are approximately equal
  ASSERT_EQ(Ae.rows(), Ae_anal.rows());
  ASSERT_EQ(Ae.cols(), Ae_anal.cols());
  for (int i = 0; i < Ae_anal.rows(); ++i) {
    for (int j = 0; j < Ae_anal.cols(); ++j) {
      EXPECT_DOUBLE_EQ(Ae.coeff(i, j), Ae_anal(i, j))
          << "mismatch in entry (" << i << ", " << j << ")";
    }
  }

  Eigen::VectorXd Vec = lse_builder.GetLoadVector();
  Eigen::VectorXd Vec_anal(6);
  // clang-format off
  Vec_anal <<     8777.93, 17666., 17666., 2660.07, 2660.07, 8777.93;
  // clang-format on

  for (int j = 0; j < Ae_anal.cols(); ++j) {
    EXPECT_NEAR(Vec(j), Vec_anal(j), 0.1) << "mismatch in entry (" << j << ")";
  }
}

/**
 *
 * @brief Test the zero hodge laplacian
 *
 * The test tests the discretiation of the Element Matrix for
 *
 * @f[
 *   \Delta_0 \\
 *   f = 0
 * @f]
 *
 * On the Octaeder with radius 1
 *
 * But not the solution of the system is tested only the buildingblocks
 * that is, only the galerkin matrix and the load vector
 *
 */

/**
 *
 * @brief Test the one hodge laplacian
 *
 * The test tests the discretiation of the problem problem
 *
 * @f[
 * - \Delta_1 u = 0
 * @f]
 *
 * On the Octaeder with radius 1
 *
 * But not the solution of the system is tested only the buildingblocks
 * that is, only the galerkin matrix and the load vector
 *
 */
TEST(projects_hldo_sphere_discretization,
     whitney_one_hodge_laplace_basic_test) {
  // Build LSE
  projects::hldo_sphere::discretization::WhitneyOneHodgeLaplace lse_builder;
  lse_builder.Compute();

  Eigen::SparseMatrix<double> Ae = lse_builder.GetGalerkinMatrix().makeSparse();

  Eigen::MatrixXd Ae_anal(18, 18);
  Eigen::MatrixXd Ae_anal_A11(12, 12);
  Eigen::MatrixXd Ae_anal_A21(6, 12);
  Ae_anal_A11.setZero();
  Ae_anal_A21.setZero();
  Ae_anal.setZero();
  // clang-format off
  Ae_anal_A11 <<     
                 4,  2,  0,  2,  2, -2,  0,  0,  0,  0,  0,  0,
                 2,  4, -2,  0,  2,  0,  0, -2,  0,  0,  0,  0,
                 0, -2,  4, -2,  0,  0,  0,  2,  0, -2,  0,  0,
                 2,  0, -2,  4,  0, -2,  0,  0,  0,  2,  0,  0,
                 2,  2,  0,  0,  4,  0, -2,  0, -2,  0,  0,  0,
                -2,  0,  0, -2,  0,  4,  2,  0,  0,  0,  0,  2,
                 0,  0,  0,  0, -2,  2,  4,  0,  2,  0,  0,  2, 
                 0, -2,  2,  0,  0,  0,  0,  4,  2,  0, -2,  0,
                 0,  0,  0,  0, -2,  0,  2,  2,  4,  0, -2,  0,
                 0,  0, -2,  2,  0,  0,  0,  0,  0,  4,  2, -2,
                 0,  0,  0,  0,  0,  0,  0, -2, -2,  2,  4, -2,
                 0,  0,  0,  0,  0,  2,  2,  0,  0, -2, -2,  4;
  Ae_anal_A21 <<     
                -1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,
                 1,  0,  0,  0, -1,  1, -1,  0,  0,  0,  0,  0,
                 0, -1,  0,  0,  1,  0,  0, -1,  1,  0,  0,  0,
                 0,  0, -1,  0,  0,  0,  0,  1,  0, -1,  1,  0,
                 0,  0,  0, -1,  0, -1,  0,  0,  0,  1,  0,  1,
                 0,  0,  0,  0,  0,  0,  1,  0, -1,  0, -1, -1;
  // clang-format on
  Ae_anal_A11 *= 1. / std::sqrt(3);
  Ae_anal_A21 *= 1. / std::sqrt(3);
  Ae_anal.topLeftCorner(12, 12) = Ae_anal_A11;
  Ae_anal.bottomLeftCorner(6, 12) = Ae_anal_A21;
  Ae_anal.topRightCorner(12, 6) = -Ae_anal_A21.transpose();

  Eigen::MatrixXd Ae_anal_mass(6, 6);
  // clang-format off
  Ae_anal_mass <<    4, 1, 1, 1, 1, 0,
                     1, 4, 1, 0, 1, 1,
                     1, 1, 4, 1, 0, 1,
                     1, 0, 1, 4, 1, 1,
                     1, 1, 0, 1, 4, 1, 
                     0, 1, 1, 1, 1, 4;
  // clang-format on
  Ae_anal_mass *= 1. / std::sqrt(3) / 4.;
  Ae_anal.bottomRightCorner(6, 6) = Ae_anal_mass;

  // Assert that the two matrices are approximately equal
  ASSERT_EQ(Ae.rows(), Ae_anal.rows());
  ASSERT_EQ(Ae.cols(), Ae_anal.cols());
  for (int i = 0; i < Ae_anal.rows(); ++i) {
    for (int j = 0; j < Ae_anal.cols(); ++j) {
      EXPECT_NEAR(Ae.coeff(i, j), Ae_anal(i, j), 1e-12)
          << "mismatch in entry (" << i << ", " << j << ")";
    }
  }

  Eigen::VectorXd Vec = lse_builder.GetLoadVector();
  Eigen::VectorXd Vec_anal(18);
  Vec_anal.setZero();
  for (int j = 0; j < Ae_anal.cols(); ++j) {
    EXPECT_NEAR(Vec(j), Vec_anal(j), 1e-12)
        << "mismatch in entry (" << j << ")";
  }
}

/**
 *
 * @brief Test the two hodge laplacian
 *
 * The test tests the discretiation of the problem problem
 *
 * @f[
 *  -\Delta_2 u = 0
 * @f]
 *
 * On the Octaeder with radius 1
 *
 * But not the solution of the system is tested only the buildingblocks
 * that is, only the galerkin matrix and the load vector
 *
 */
TEST(projects_hldo_sphere_discretization,
     whitney_two_hodge_laplace_basic_test) {
  // Build LSE
  projects::hldo_sphere::discretization::WhitneyTwoHodgeLaplace lse_builder;
  lse_builder.Compute();

  Eigen::SparseMatrix<double> Ae = lse_builder.GetGalerkinMatrix().makeSparse();

  Eigen::MatrixXd Ae_anal(20, 20);
  Eigen::MatrixXd Ae_anal_A11(12, 12);
  Eigen::MatrixXd Ae_anal_A12(12, 8);
  Ae_anal.setZero();

  // clang-format off
  Ae_anal_A11 <<  
           10, -1,  0, -1, -1,  1,  0,  0,  0,  0,  0,  0,
           -1, 10,  1,  0, -1,  0,  0,  1,  0,  0,  0,  0,
            0,  1, 10,  1,  0,  0,  0, -1,  0,  1,  0,  0,
           -1,  0,  1, 10,  0,  1,  0,  0,  0, -1,  0,  0,
           -1, -1,  0,  0, 10,  0,  1,  0,  1,  0,  0,  0,
            1,  0,  0,  1,  0, 10, -1,  0,  0,  0,  0, -1,
            0,  0,  0,  0,  1, -1, 10,  0, -1,  0,  0, -1,
            0,  1, -1,  0,  0,  0,  0, 10, -1,  0,  1,  0,
            0,  0,  0,  0,  1,  0, -1, -1, 10,  0,  1,  0,
            0,  0,  1, -1,  0,  0,  0,  0,  0, 10, -1,  1,
            0,  0,  0,  0,  0,  0,  0,  1,  1, -1, 10,  1,
            0,  0,  0,  0,  0, -1, -1,  0,  0,  1,  1, 10;
  Ae_anal_A12 <<  
           -1,  0,  0,  0,  0,  0,  1,  0,
           -1,  0,  1,  0,  0,  0,  0,  0,
            0,  0, -1,  0,  1,  0,  0,  0,
            0,  0,  0,  0, -1,  0,  1,  0,
           -1,  1,  0,  0,  0,  0,  0,  0, 
            0,  0,  0,  0,  0,  0, -1,  1,
            0, -1,  0,  0,  0,  0,  0,  1,
            0,  0, -1,  1,  0,  0,  0,  0,
            0, -1,  0,  1,  0,  0,  0,  0,
            0,  0,  0,  0, -1,  1,  0,  0, 
            0,  0,  0, -1,  0,  1,  0,  0,
            0,  0,  0,  0,  0, -1,  0,  1;
  // clang-format on
  Ae_anal_A11 *= 1. / std::sqrt(3) / 12.;
  Ae_anal.topLeftCorner(12, 12) = Ae_anal_A11;
  Ae_anal.topRightCorner(12, 8) = Ae_anal_A12;
  Ae_anal.bottomLeftCorner(8, 12) = -Ae_anal_A12.transpose();

  // Assert that the two matrices are approximately equal
  ASSERT_EQ(Ae.rows(), Ae_anal.rows());
  ASSERT_EQ(Ae.cols(), Ae_anal.cols());
  for (int i = 0; i < Ae_anal.rows(); ++i) {
    for (int j = 0; j < Ae_anal.cols(); ++j) {
      EXPECT_NEAR(Ae.coeff(i, j), Ae_anal(i, j), 1e-12)
          << "mismatch in entry (" << i << ", " << j << ")";
    }
  }

  Eigen::VectorXd Vec = lse_builder.GetLoadVector();
  Eigen::VectorXd Vec_anal(20);
  Vec_anal.setZero();
  // clang-format off
  // clang-format on
  for (int j = 0; j < Ae_anal.cols(); ++j) {
    EXPECT_NEAR(Vec(j), Vec_anal(j), 1e-12)
        << "mismatch in entry (" << j << ")";
  }
}

/**
 *
 * @brief Test the two hodge laplacian
 *
 * The test tests the discretiation of the Element Matrix for
 *
 * @f[
 *   \Delta_0 \\
 *   f = 100^2 (Cos[z] + Sin[x] + Sin[y]) + (1/( x^2 + y^2 + z^2))(2 x Cos[x] +
 * 2 y Cos[y] + x^2 Cos[z] + y^2 Cos[z] + y^2 Sin[x] + z^2 Sin[x] + x^2 Sin[y] +
 * z^2 Sin[y] - 2 z Sin[z])
 * @f]
 *
 * On the Octaeder with radius 1
 *
 * But not the solution of the system is tested only the buildingblocks
 * that is, only the galerkin matrix and the load vector
 *
 */
TEST(projects_hldo_sphere_discretization, whitney_two_hodge_laplace_load_test) {
  // Build LSE
  // righthandside for the zero and two form
  projects::hldo_sphere::discretization::WhitneyTwoHodgeLaplace lse_builder;
  auto f = [](const Eigen::Vector3d& x_vec) -> double {
    auto Power = [](double a, double b) -> double { return pow(a, b); };
    auto Cos = [](double a) -> double { return cos(a); };
    auto Sin = [](double a) -> double { return sin(a); };
    // first scale to the circle
    Eigen::Vector3d x_ = x_vec / x_vec.norm();
    double x = x_(0);
    double y = x_(1);
    double z = x_(2);

    // autogenerated by mathematica
    double ret =
        Power(100, 2) * (Cos(z) + Sin(x) + Sin(y)) +
        (2 * x * Cos(x) + 2 * y * Cos(y) + Power(x, 2) * Cos(z) +
         Power(y, 2) * Cos(z) + Power(y, 2) * Sin(x) + Power(z, 2) * Sin(x) +
         Power(x, 2) * Sin(y) + Power(z, 2) * Sin(y) - 2 * z * Sin(z)) /
            (Power(x, 2) + Power(y, 2) + Power(z, 2));

    return ret;
  };
  std::function<double(const Eigen::Matrix<double, 3, 1>&)> f0_ = f;
  lse_builder.SetLoadFunction(f0_);
  lse_builder.Compute();

  Eigen::VectorXd Vec = lse_builder.GetLoadVector();
  Eigen::VectorXd Vec_anal(20);
  Vec_anal.setZero();
  // clang-format off
  Vec_anal.tail(8) <<  16712.4, 16712.4, 7256.47, 7256.47, 
                      -2199.47, -2199.47, 7256.47, 7256.47;

  for (int j = 0; j < Vec_anal.cols(); ++j) {
    EXPECT_NEAR(Vec(j), Vec_anal(j), 0.1) << "mismatch in entry (" << j << ")";
  }
}

/**
 *
 * @brief Test the two hodge laplacian
 *
 * The test tests the discretiation of the Element Matrix for
 *
 * @f[
 *   \Delta_0 \\
 *   f = 4^2 * 5.2
 * @f]
 *
 * On the Octaeder with radius 1
 *
 * But not the solution of the system is tested only the buildingblocks
 * that is, only the galerkin matrix and the load vector
 *
 */
TEST(projects_hldo_sphere_discretization, whitney_two_hodge_laplace_load_test_const) {
  // Build LSE
  // righthandside for the zero and two form
  projects::hldo_sphere::discretization::WhitneyTwoHodgeLaplace lse_builder;
  auto f = [](const Eigen::Vector3d& x_vec) -> double {
    double ret = pow(4, 2) * 5.2;
    return ret;
  };
  std::function<double(const Eigen::Matrix<double, 3, 1>&)> f0_ = f;
  lse_builder.SetLoadFunction(f0_);
  lse_builder.Compute();

  Eigen::VectorXd Vec = lse_builder.GetLoadVector();
  Eigen::VectorXd Vec_anal(20);
  Vec_anal.setZero();
  // clang-format off
  double c = 16. * sqrt(1.5) * sqrt(0.5) * 5.2;
  Vec_anal.tail(8) << c,c,c,c,c,c,c,c;


  std::cout << "Mat\n" << lse_builder.GetGalerkinMatrix().makeDense() << "\n\nLoad vec \n" << Vec << "\n\n";
                      

  for (int j = 0; j < Vec_anal.cols(); ++j) {
    EXPECT_NEAR(Vec(j), Vec_anal(j), 0.1) << "mismatch in entry (" << j << ")";
  }
}
