/**
 * @file dirac_operator_test.cc
 * @brief Solve hodge laplacian source problem for fixed function f and variable
 * k
 */

#include <dirac_operator_source_problem.h>
#include <lf/mesh/hybrid2d/mesh_factory.h>
#include <lf/mesh/utils/utils.h>
#include <norms.h>
#include <results_processing.h>
#include <sphere_triag_mesh_builder.h>

#include <chrono>

using lf::uscalfe::operator-;
using complex = std::complex<double>;

/**
 * @brief Prints the L2 norm errors and the Supremum of the experiment and
 * creates vtk plots for a function u
 */
int main(int argc, char *argv[]) {
  if (argc != 4) {
    std::cerr << "Usage: " << argv[0] << " max_refinement_level k radius"
              << std::endl;
    exit(1);
  }

  double k;
  const unsigned refinement_level = atoi(argv[1]);
  double r;
  sscanf(argv[2], "%lf", &k);
  sscanf(argv[3], "%lf", &r);
  std::cout << "max_refinement_level : " << refinement_level << std::endl;

  // Read the mesh from the gmsh file
  std::unique_ptr<lf::mesh::MeshFactory> factory =
      std::make_unique<lf::mesh::hybrid2d::MeshFactory>(3);

  projects::hldo_sphere::mesh::SphereTriagMeshBuilder sphere =
      projects::hldo_sphere::mesh::SphereTriagMeshBuilder(std::move(factory));

  // we always take the same radius
  sphere.setRadius(r);

  // mathematica function output requries the following helpers
  auto Power = [](complex a, complex b) -> complex { return std::pow(a, b); };
  auto Complex = [](double a, double b) -> complex { return complex(a, b); };
  auto Sin = [](complex a) -> complex { return std::sin(a); };
  auto Cos = [](complex a) -> complex { return std::cos(a); };
  auto Sqrt = [](complex a) -> complex { return std::sqrt(a); };

  // righthandside for the zero and two form
  auto f_zero = [&](const Eigen::Vector3d &x_vec) -> complex {
    // first scale to the circle
    Eigen::Vector3d x_ = x_vec;
    double x = x_(0);
    double y = x_(1);
    double z = x_(2);

    // autogenerated by mathematica
    complex ret = (Complex(0, 1) *
                   (Complex(0, 1) * x * z * Cos(x) +
                    (Complex(0, 1) * x * y +
                     k * (Power(x, 2) + Power(y, 2) + Power(z, 2))) *
                        Cos(y) +
                    Complex(0, 1) * y * z * Cos(z) + k * Power(x, 2) * Sin(x) +
                    k * Power(y, 2) * Sin(x) + Complex(0, 2) * z * Sin(x) +
                    k * Power(z, 2) * Sin(x) + Complex(0, 2) * x * Sin(y) +
                    k * Power(x, 2) * Sin(z) + Complex(0, 2) * y * Sin(z) +
                    k * Power(y, 2) * Sin(z) + k * Power(z, 2) * Sin(z))) /
                  (Power(x, 2) + Power(y, 2) + Power(z, 2));

    return ret;
  };

  // righthandside for the one form
  auto f_one = [&](const Eigen::Vector3d &x_vec) -> Eigen::VectorXcd {
    // first scale to the circle
    Eigen::Vector3d x_ = x_vec;
    double x = x_(0);
    double y = x_(1);
    double z = x_(2);

    // autogenerated by mathematica
    Eigen::VectorXcd ret(3);
    ret << Cos(x) +
               (y * Cos(z)) / Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)) +
               (z * Sin(y)) / Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)) -
               (x *
                ((x * Cos(x)) / Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)) +
                 (z * Cos(z)) / Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)) -
                 (y * Sin(y)) /
                     Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)))) /
                   Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)) +
               (Complex(0, 1) * k *
                (-(x * z * Sin(x)) + (Power(y, 2) + Power(z, 2)) * Sin(y) -
                 x * y * Sin(z))) /
                   (Power(x, 2) + Power(y, 2) + Power(z, 2)),
        (z * Cos(x)) / Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)) -
            (x * Cos(z)) / Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)) -
            Sin(y) -
            (y *
             ((x * Cos(x)) / Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)) +
              (z * Cos(z)) / Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)) -
              (y * Sin(y)) / Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)))) /
                Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)) +
            (Complex(0, 1) * k *
             (-(y * z * Sin(x)) - x * y * Sin(y) +
              (Power(x, 2) + Power(z, 2)) * Sin(z))) /
                (Power(x, 2) + Power(y, 2) + Power(z, 2)),
        -((y * Cos(x)) / Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2))) +
            Cos(z) -
            (x * Sin(y)) / Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)) -
            (z *
             ((x * Cos(x)) / Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)) +
              (z * Cos(z)) / Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)) -
              (y * Sin(y)) / Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)))) /
                Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)) +
            (Complex(0, 1) * k *
             ((Power(x, 2) + Power(y, 2)) * Sin(x) -
              z * (x * Sin(y) + y * Sin(z)))) /
                (Power(x, 2) + Power(y, 2) + Power(z, 2));
    return ret;
  };

  // righthandside for the two form
  auto f_two = [&](const Eigen::Vector3d &x_vec) -> complex {
    // first scale to the circle
    Eigen::Vector3d x_ = x_vec;
    double x = x_(0);
    double y = x_(1);
    double z = x_(2);

    // autogenerated by mathematica
    complex ret = (y * Cos(x)) / Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)) +
                  (Complex(0, 1) * k +
                   z / Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2))) *
                      Cos(y) +
                  (x * Cos(z)) / Sqrt(Power(x, 2) + Power(y, 2) + Power(z, 2)) +
                  Complex(0, 1) * k * Sin(x) + Complex(0, 1) * k * Sin(z);
    return ret;
  };

  // Compute the analytic solution of the problem
  auto u_zero = [&](const Eigen::Vector3d x_vec) -> complex {
    // first scale to the circle
    Eigen::Vector3d x_ = x_vec;
    double x = x_(0);
    double y = x_(1);
    double z = x_(2);

    return Cos(z) + Sin(x) + Sin(y);
  };

  // Compute the analytic solution of the problem
  auto u_one = [&](const Eigen::Vector3d x_vec) -> Eigen::Vector3cd {
    // first scale to the circle
    Eigen::Vector3d x_ = x_vec;
    double x = x_(0);
    double y = x_(1);
    double z = x_(2);

    Eigen::VectorXcd ret(3);

    // mathematica autocompute
    ret << (-(x * z * Sin(x)) + (Power(y, 2) + Power(z, 2)) * Sin(y) -
            x * y * Sin(z)) /
               (Power(x, 2) + Power(y, 2) + Power(z, 2)),
        (-(y * z * Sin(x)) - x * y * Sin(y) +
         (Power(x, 2) + Power(z, 2)) * Sin(z)) /
            (Power(x, 2) + Power(y, 2) + Power(z, 2)),
        ((Power(x, 2) + Power(y, 2)) * Sin(x) - z * (x * Sin(y) + y * Sin(z))) /
            (Power(x, 2) + Power(y, 2) + Power(z, 2));
    return ret;
  };

  // Compute the analytic solution of the problem
  auto u_two = [&](const Eigen::Vector3d x_vec) -> complex {
    // first scale to the circle
    Eigen::Vector3d x_ = x_vec;
    double x = x_(0);
    double y = x_(1);
    double z = x_(2);

    return Cos(z) + Sin(x) + Sin(y);
  };

  // Solve the problem for each mesh in the hierarchy
  std::vector<projects::hldo_sphere::post_processing::ProblemSolution<complex>>
      solutions(refinement_level + 1);

  projects::hldo_sphere::discretization::DiracOperatorSourceProblem lse_builder;
  lse_builder.SetLoadFunctions(f_zero, f_one, f_two);

  // start timer for total time
  std::chrono::steady_clock::time_point start_time_total =
      std::chrono::steady_clock::now();

  for (lf::base::size_type lvl = 0; lvl < refinement_level + 1; ++lvl) {
    std::cout << "\nStart computation of refinement_level " << lvl << " "
              << std::flush;

    // start timer
    std::chrono::steady_clock::time_point start_time =
        std::chrono::steady_clock::now();

    // get mesh
    sphere.setRefinementLevel(lvl);
    const std::shared_ptr<lf::mesh::Mesh> mesh = sphere.Build();

    // end timer
    std::chrono::steady_clock::time_point end_time =
        std::chrono::steady_clock::now();
    double elapsed_sec = std::chrono::duration_cast<std::chrono::milliseconds>(
                             end_time - start_time)
                             .count() /
                         1000.;

    std::cout << " -> Built Mesh " << elapsed_sec << " [s] " << std::flush;

    auto &sol = solutions[lvl];
    sol.mesh = mesh;

    // setup the problem
    lse_builder.SetMesh(mesh);
    lse_builder.SetK(k);

    // start timer
    start_time = std::chrono::steady_clock::now();

    // compute the system
    lse_builder.Compute();

    // end timer
    end_time = std::chrono::steady_clock::now();
    elapsed_sec = std::chrono::duration_cast<std::chrono::milliseconds>(
                      end_time - start_time)
                      .count() /
                  1000.;

    std::cout << " -> Computed LSE " << elapsed_sec << " [s] " << std::flush;

    // start timer
    start_time = std::chrono::steady_clock::now();

    // solve the system
    lse_builder.Solve();

    // end timer
    end_time = std::chrono::steady_clock::now();

    elapsed_sec = std::chrono::duration_cast<std::chrono::milliseconds>(
                      end_time - start_time)
                      .count() /
                  1000.;

    std::cout << " -> Solved System " << elapsed_sec << " [s] " << std::flush;

    // store solutions
    sol.mu_zero = lse_builder.GetMu(0);
    sol.mu_one = lse_builder.GetMu(1);
    sol.mu_two = lse_builder.GetMu(2);
  }

  // end timer total
  std::chrono::steady_clock::time_point end_time_total =
      std::chrono::steady_clock::now();
  double elapsed_sec_total =
      std::chrono::duration_cast<std::chrono::milliseconds>(end_time_total -
                                                            start_time_total)
          .count() /
      1000.;

  std::cout << "\nTotal computation time for all levels " << elapsed_sec_total
            << " [s]\n";

  projects::hldo_sphere::post_processing::process_results<
      decltype(u_zero), decltype(u_one), decltype(u_two), complex>(
      "test", solutions, u_zero, u_one, u_two);

  return 0;
}
