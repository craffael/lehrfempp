#include <gtest/gtest.h>
#include <lf/assemble/assemble.h>
#include <lf/assemble/coomatrix.h>
#include <lf/assemble/dofhandler.h>
#include <lf/base/base.h>
#include <lf/base/span.h>
#include <lf/geometry/geometry.h>
#include <lf/geometry/tria_o1.h>
#include <lf/mesh/hybrid2d/mesh_factory.h>
#include <lf/mesh/utils/all_codim_mesh_data_set.h>
#include <lf/mesh/utils/utils.h>
#include <rot_whitney_one_div_matrix_provider.h>
#include <sphere_triag_mesh_builder.h>
#include <whitney_one_mass_matrix_provider.h>
#include <whitney_two_mass_matrix_provider.h>
#include <whitney_two_vector_provider.h>

#include <array>
#include <cmath>

using complex = std::complex<double>;

/**
 *
 * @brief Test the element matrix provider for the whitney one form mass
 * matrix
 *
 * The whitney one form mass matrix the same as the matrix based on
 * the integral over the dotproduct of two rotated whitney one basis
 * functions.
 *
 * Test the element vector provider on the triangle
 * ((1,0,0), (0,1,0), (0,0,1))
 *
 * with relative edge orientations
 *
 * s_0 = 1, s_1 = 1, s_2 = -1
 *
 * And the linear form
 *
 * @f[
 *  \int_K\ \bm{u} \cdot \bm{v} \,\mathrm{d}x, \quad u, v \in
 * \bm{H}(curl_{\Gamma}, \partial\mathbb{S})
 * @f]
 *
 * Using the whitney one forms
 *
 * @note the matrix can as well be used for the rotated whitney one
 * forms instead of the whitney one forms
 *
 * For analytical solution see assemby.pdf
 *
 */
TEST(projects_hldo_sphere_assembly,
     whitney_one_mass_matrix_assembler_test_regular) {
  // Build Mesh
  const auto trig = lf::base::RefEl::kTria();
  const auto seg = lf::base::RefEl::kSegment();

  // Define Vertices
  Eigen::MatrixXd vertices(3, 3);
  // clang-format off
  vertices << 1, 0, 0,
              0, 1, 0,
              0, 0, 1;
  // clang-format on
  lf::mesh::hybrid2d::MeshFactory factory(3);
  factory.AddPoint(vertices.col(0));
  factory.AddPoint(vertices.col(1));
  factory.AddPoint(vertices.col(2));

  // Build Segments
  // First define directions
  std::vector<std::array<lf::mesh::MeshFactory::size_type, 2>> edge_nodes(3);
  edge_nodes[0] = {0, 1};
  edge_nodes[1] = {1, 2};
  edge_nodes[2] = {0, 2};

  // Build segments based on directions
  std::vector<Eigen::MatrixXd> edge_endpoints(3);
  std::vector<std::unique_ptr<lf::geometry::Geometry>> edge_geom(3);
  for (int i = 0; i < 3; i++) {
    edge_endpoints[i] = Eigen::MatrixXd::Zero(3, 2);
    edge_endpoints[i].col(0) = vertices.col(edge_nodes[i][0]);
    edge_endpoints[i].col(1) = vertices.col(edge_nodes[i][1]);
    edge_geom[i] = std::make_unique<lf::geometry::SegmentO1>(edge_endpoints[i]);
    factory.AddEntity(seg, nonstd::span(edge_nodes[i].data(), 2),
                      std::move(edge_geom[i]));
  }

  // build triangle
  std::unique_ptr<lf::geometry::Geometry> geom =
      std::make_unique<lf::geometry::TriaO1>(vertices);
  const std::array<lf::mesh::MeshFactory::size_type, 3> nodes = {0, 1, 2};
  factory.AddEntity(trig, nonstd::span(nodes.data(), 3), std::move(geom));

  const auto mesh = factory.Build();
  const auto element = mesh->EntityByIndex(0, 0);
  // Compute the element matrix for the triangle
  const auto elem_mat_provider =
      projects::hldo_sphere::assemble::WhitneyOneMassMatrixProvider();
  const Eigen::MatrixXd Ae = elem_mat_provider.Eval(*element);
  // Construct the analytically computed element matrix
  Eigen::MatrixXd Ae_anal(3, 3);

  // autogenerated mathematica
  Ae_anal << 5 / (12. * sqrt(3)), -0.08333333333333333 * 1 / sqrt(3),
      1 / (12. * sqrt(3)), -0.08333333333333333 * 1 / sqrt(3),
      5 / (12. * sqrt(3)), 1 / (12. * sqrt(3)), 1 / (12. * sqrt(3)),
      1 / (12. * sqrt(3)), 5 / (12. * sqrt(3));
  // Assert that the two matrices are approximately equal
  ASSERT_EQ(Ae.rows(), Ae_anal.rows());
  ASSERT_EQ(Ae.cols(), Ae_anal.cols());
  for (int i = 0; i < Ae_anal.rows(); ++i) {
    for (int j = 0; j < Ae_anal.cols(); ++j) {
      EXPECT_DOUBLE_EQ(Ae(i, j), Ae_anal(i, j))
          << "mismatch in entry (" << i << ", " << j << ")";
    }
  }
}

/**
 *
 * @brief Test the element matrix provider for the whitney two form
 *
 * Test the element vector provider on the triangle
 * ((1,0,0), (0,1,0), (0,0,1))
 *
 * with relative edge orientations
 *
 * s_0 = 1, s_1 = 1, s_2 = -1
 *
 * And the linear form
 *
 * @f[
 *  \int_K\ div(u) v \,\mathrm{d}x, \quad \bm{u} \in
 * \bm{H}(div_{\Gamma}, \partial\mathbb{S})
 * v \in L^2(\partial \mathbb{S})
 * @f]
 *
 * Using the rotated whitney one forms for u and the whitney two forms for v
 *
 * For analytical solution see assemby.pdf
 *
 */
TEST(projects_hldo_sphere_assembly,
     rot_w_one_form_div_matrix_assembler_test_regular) {
  // Build Mesh
  const auto trig = lf::base::RefEl::kTria();
  const auto seg = lf::base::RefEl::kSegment();

  // Define Vertices
  Eigen::MatrixXd vertices(3, 3);
  // clang-format off
  vertices << 1, 0, 0,
              0, 1, 0,
              0, 0, 1;
  // clang-format on
  lf::mesh::hybrid2d::MeshFactory factory(3);
  factory.AddPoint(vertices.col(0));
  factory.AddPoint(vertices.col(1));
  factory.AddPoint(vertices.col(2));

  // Build Segments
  // First define directions
  std::vector<std::array<lf::mesh::MeshFactory::size_type, 2>> edge_nodes(3);
  edge_nodes[0] = {0, 1};
  edge_nodes[1] = {1, 2};
  edge_nodes[2] = {0, 2};

  // Build segments based on directions
  std::vector<Eigen::MatrixXd> edge_endpoints(3);
  std::vector<std::unique_ptr<lf::geometry::Geometry>> edge_geom(3);
  for (int i = 0; i < 3; i++) {
    edge_endpoints[i] = Eigen::MatrixXd::Zero(3, 2);
    edge_endpoints[i].col(0) = vertices.col(edge_nodes[i][0]);
    edge_endpoints[i].col(1) = vertices.col(edge_nodes[i][1]);
    edge_geom[i] = std::make_unique<lf::geometry::SegmentO1>(edge_endpoints[i]);
    factory.AddEntity(seg, nonstd::span(edge_nodes[i].data(), 2),
                      std::move(edge_geom[i]));
  }

  // build triangle
  std::unique_ptr<lf::geometry::Geometry> geom =
      std::make_unique<lf::geometry::TriaO1>(vertices);
  const std::array<lf::mesh::MeshFactory::size_type, 3> nodes = {0, 1, 2};
  factory.AddEntity(trig, nonstd::span(nodes.data(), 3), std::move(geom));

  const auto mesh = factory.Build();
  const auto element = mesh->EntityByIndex(0, 0);
  // Compute the element matrix for the triangle
  const auto elem_mat_provider =
      projects::hldo_sphere::assemble::RotWhitneyOneDivMatrixProvider();
  const Eigen::MatrixXd Ae = elem_mat_provider.Eval(*element);
  // Construct the analytically computed element matrix
  Eigen::MatrixXd Ae_anal(3, 1);
  // clang-format off
  Ae_anal <<  -1, -1, 1;
  // clang-format on
  // Assert that the two matrices are approximately equal
  ASSERT_EQ(Ae.rows(), Ae_anal.rows());
  ASSERT_EQ(Ae.cols(), Ae_anal.cols());
  for (int i = 0; i < Ae_anal.rows(); ++i) {
    EXPECT_DOUBLE_EQ(Ae(i), Ae_anal(i)) << "mismatch in entry (" << i << ")";
  }
}

/**
 *
 * @brief Test the element matrix provider for the whitney two mass matrix
 *
 * Test the element vector provider on the triangle
 * ((1,0,0), (0,1,0), (0,0,1))
 *
 * with relative edge orientations
 *
 * s_0 = -1, s_1 = -1, s_2 = 1
 *
 * And the linear form
 *
 * @f[
 *  \int_K\ u\ v \,\mathrm{d}x, \quad
 * u, v \in L^2(\partial \mathbb{S})
 * @f]
 *
 * Using the whitney two forms
 *
 * For analytical solution see assemby.pdf
 *
 */
TEST(projects_hldo_sphere_assembly,
     whitney_two_mass_matrix_assembler_test_regular) {
  // Build Mesh
  const auto trig = lf::base::RefEl::kTria();
  const auto seg = lf::base::RefEl::kSegment();

  // Define Vertices
  Eigen::MatrixXd vertices(3, 3);
  // clang-format off
  vertices << 1, 0, 0,
              0, 1, 0,
              0, 0, 1;
  // clang-format on
  lf::mesh::hybrid2d::MeshFactory factory(3);
  factory.AddPoint(vertices.col(0));
  factory.AddPoint(vertices.col(1));
  factory.AddPoint(vertices.col(2));

  // Build Segments
  // First define directions
  std::vector<std::array<lf::mesh::MeshFactory::size_type, 2>> edge_nodes(3);
  edge_nodes[0] = {0, 1};
  edge_nodes[1] = {1, 2};
  edge_nodes[2] = {0, 2};

  // Build segments based on directions
  std::vector<Eigen::MatrixXd> edge_endpoints(3);
  std::vector<std::unique_ptr<lf::geometry::Geometry>> edge_geom(3);
  for (int i = 0; i < 3; i++) {
    edge_endpoints[i] = Eigen::MatrixXd::Zero(3, 2);
    edge_endpoints[i].col(0) = vertices.col(edge_nodes[i][0]);
    edge_endpoints[i].col(1) = vertices.col(edge_nodes[i][1]);
    edge_geom[i] = std::make_unique<lf::geometry::SegmentO1>(edge_endpoints[i]);
    factory.AddEntity(seg, nonstd::span(edge_nodes[i].data(), 2),
                      std::move(edge_geom[i]));
  }

  // build triangle
  std::unique_ptr<lf::geometry::Geometry> geom =
      std::make_unique<lf::geometry::TriaO1>(vertices);
  const std::array<lf::mesh::MeshFactory::size_type, 3> nodes = {0, 1, 2};
  factory.AddEntity(trig, nonstd::span(nodes.data(), 3), std::move(geom));

  const auto mesh = factory.Build();
  const auto element = mesh->EntityByIndex(0, 0);
  // Compute the element matrix for the triangle
  const auto elem_mat_provider =
      projects::hldo_sphere::assemble::WhitneyTwoMassMatrixProvider();
  const Eigen::MatrixXd Ae = elem_mat_provider.Eval(*element);
  // Construct the analytically computed element matrix
  Eigen::MatrixXd Ae_anal = Eigen::MatrixXd::Ones(1, 1);
  Ae_anal *= sqrt(3) / 2.;
  // Assert that the two matrices are approximately equal
  ASSERT_EQ(Ae.rows(), Ae_anal.rows());
  ASSERT_EQ(Ae.cols(), Ae_anal.cols());
  EXPECT_DOUBLE_EQ(Ae(0), Ae_anal(0));
}

/**
 *
 * @brief Test the element vector provider for the two-form
 *
 * Test the element vector provider on the triangle
 * ((1,0,0), (0,1,0), (0,0,1))
 *
 * with relative edge orientations
 *
 * s_0 = 1, s_1 = 1, s_2 = -1
 *
 * And the linear form
 *
 * @f[
 *  \int_K\ f \cdot v \,\mathrm{d}x, \quad f, v \in H^1
 * @f]
 *
 * using the load function
 *
 * @f[
 *  f((x_0,x_1, x_2)) = x_0 / \|x\|
 * @f]
 *
 * And the cellwise constant basis functions
 *
 * For analytical solution see assemby.pdf
 */
TEST(projects_hldo_sphere_assembly, vector_provider_two_form_test_regular) {
  // Build Mesh
  const auto trig = lf::base::RefEl::kTria();
  const auto seg = lf::base::RefEl::kSegment();

  // Define Vertices
  Eigen::MatrixXd vertices(3, 3);
  // clang-format off
  vertices << 1, 0, 0,
              0, 1, 0,
              0, 0, 1;
  // clang-format on
  lf::mesh::hybrid2d::MeshFactory factory(3);
  factory.AddPoint(vertices.col(0));
  factory.AddPoint(vertices.col(1));
  factory.AddPoint(vertices.col(2));

  // Build Segments
  // First define directions
  std::vector<std::array<lf::mesh::MeshFactory::size_type, 2>> edge_nodes(3);
  edge_nodes[0] = {0, 1};
  edge_nodes[1] = {1, 2};
  edge_nodes[2] = {0, 2};

  // Build segments based on directions
  std::vector<Eigen::MatrixXd> edge_endpoints(3);
  std::vector<std::unique_ptr<lf::geometry::Geometry>> edge_geom(3);
  for (int i = 0; i < 3; i++) {
    edge_endpoints[i] = Eigen::MatrixXd::Zero(3, 2);
    edge_endpoints[i].col(0) = vertices.col(edge_nodes[i][0]);
    edge_endpoints[i].col(1) = vertices.col(edge_nodes[i][1]);
    edge_geom[i] = std::make_unique<lf::geometry::SegmentO1>(edge_endpoints[i]);
    factory.AddEntity(seg, nonstd::span(edge_nodes[i].data(), 2),
                      std::move(edge_geom[i]));
  }

  // Build triangle
  std::unique_ptr<lf::geometry::Geometry> geom =
      std::make_unique<lf::geometry::TriaO1>(vertices);
  const std::array<lf::mesh::MeshFactory::size_type, 3> nodes = {0, 1, 2};
  factory.AddEntity(trig, nonstd::span(nodes.data(), 3), std::move(geom));
  const auto mesh = factory.Build();

  // Define function f
  auto f = [&](const Eigen::Vector3d x) -> double { return x(0) / x.norm(); };

  const auto element = mesh->EntityByIndex(0, 0);
  // Compute the element vec for the triangle
  const auto elem_vec_provider =
      projects::hldo_sphere::assemble::WhitneyTwoVectorProvider<double>(f);
  const Eigen::VectorXd Ae = elem_vec_provider.Eval(*element);
  // Construct the analytically computed element matrix
  Eigen::VectorXd Ae_anal(1);
  // clang-format off
  Ae_anal <<  1 / sqrt(6.);
  // clang-format on
  // Assert that the two matrices are approximately equal
  ASSERT_EQ(Ae.rows(), Ae_anal.rows());
  ASSERT_EQ(Ae.cols(), Ae_anal.cols());
  EXPECT_DOUBLE_EQ(Ae(0), Ae_anal(0)) << "mismatch in entry (0)";
}

/**
 *
 * @brief Test the element vector provider for the two-form with complex
 * loadfunction
 *
 * Test the element vector provider on the triangle
 * ((1,0,0), (0,1,0), (0,0,1))
 *
 * with relative edge orientations
 *
 * s_0 = 1, s_1 = 1, s_2 = -1
 *
 * And the linear form
 *
 * @f[
 *  \int_K\ f \cdot v \,\mathrm{d}x, \quad f, v \in H^1
 * @f]
 *
 * using the load function
 *
 * @f[
 *  f((x_0,x_1, x_2)) = (i x_0 + x_1) / \|x\|
 * @f]
 *
 * And the cellwise constant basis functions
 *
 * For analytical solution see assemby.pdf
 */
TEST(projects_hldo_sphere_assembly,
     vector_provider_two_form_test_regular_complex) {
  // Build Mesh
  const auto trig = lf::base::RefEl::kTria();
  const auto seg = lf::base::RefEl::kSegment();

  // Define Vertices
  Eigen::MatrixXd vertices(3, 3);
  // clang-format off
  vertices << 1, 0, 0,
              0, 1, 0,
              0, 0, 1;
  // clang-format on
  lf::mesh::hybrid2d::MeshFactory factory(3);
  factory.AddPoint(vertices.col(0));
  factory.AddPoint(vertices.col(1));
  factory.AddPoint(vertices.col(2));

  // Build Segments
  // First define directions
  std::vector<std::array<lf::mesh::MeshFactory::size_type, 2>> edge_nodes(3);
  edge_nodes[0] = {0, 1};
  edge_nodes[1] = {1, 2};
  edge_nodes[2] = {0, 2};

  // Build segments based on directions
  std::vector<Eigen::MatrixXd> edge_endpoints(3);
  std::vector<std::unique_ptr<lf::geometry::Geometry>> edge_geom(3);
  for (int i = 0; i < 3; i++) {
    edge_endpoints[i] = Eigen::MatrixXd::Zero(3, 2);
    edge_endpoints[i].col(0) = vertices.col(edge_nodes[i][0]);
    edge_endpoints[i].col(1) = vertices.col(edge_nodes[i][1]);
    edge_geom[i] = std::make_unique<lf::geometry::SegmentO1>(edge_endpoints[i]);
    factory.AddEntity(seg, nonstd::span(edge_nodes[i].data(), 2),
                      std::move(edge_geom[i]));
  }

  // Build triangle
  std::unique_ptr<lf::geometry::Geometry> geom =
      std::make_unique<lf::geometry::TriaO1>(vertices);
  const std::array<lf::mesh::MeshFactory::size_type, 3> nodes = {0, 1, 2};
  factory.AddEntity(trig, nonstd::span(nodes.data(), 3), std::move(geom));
  const auto mesh = factory.Build();

  // Define function f
  auto f = [&](const Eigen::Vector3d x) -> complex {
    return (complex(0, 1) * x(0) + x(1)) / x.norm();
  };

  const auto element = mesh->EntityByIndex(0, 0);
  // Compute the element vec for the triangle
  const auto elem_vec_provider =
      projects::hldo_sphere::assemble::WhitneyTwoVectorProvider<complex>(f);
  const Eigen::VectorXcd Ae = elem_vec_provider.Eval(*element);
  // Construct the analytically computed element matrix
  Eigen::VectorXcd Ae_anal(1);
  // clang-format off
  Ae_anal <<  complex(1,1) / sqrt(6.);
  // clang-format on
  // Assert that the two matrices are approximately equal
  ASSERT_EQ(Ae.rows(), Ae_anal.rows());
  ASSERT_EQ(Ae.cols(), Ae_anal.cols());
  EXPECT_DOUBLE_EQ(Ae(0).real(), Ae_anal(0).real()) << "mismatch in entry (0)";
  EXPECT_DOUBLE_EQ(Ae(0).imag(), Ae_anal(0).real()) << "mismatch in entry (0)";
}

// Additional  tests for the funciton
//
// @f[
// f(\vec{x}) = k^2 (\sin (x)+\sin (y)+\cos (z))+\frac{x^2 \sin (y)+x^2 \cos
// (z)+y^2 \sin(x) + z ^ 2 \sin(x) + 2 x \cos(x) + y ^ 2 \cos(z) + z ^ 2 \sin(y)
// + 2 y \cos(y) - 2 z \sin(z) } {x ^ 2 + y ^ 2 + z ^ 2} \\
// k = 0.4
// @f]
//
// for all triagles on the octacon with radius 1
TEST(projects_hldo_sphere_assembly, vector_provider_two_form_test_octacon) {
  // Build Mesh
  std::unique_ptr<lf::mesh::MeshFactory> factory =
      std::make_unique<lf::mesh::hybrid2d::MeshFactory>(3);

  projects::hldo_sphere::mesh::SphereTriagMeshBuilder sphere =
      projects::hldo_sphere::mesh::SphereTriagMeshBuilder(std::move(factory));

  sphere.setRefinementLevel(0);
  sphere.setRadius(1);

  std::shared_ptr<const lf::mesh::Mesh> mesh = sphere.Build();

  // Define function f
  double k = 0.4;
  const auto f = [&](const Eigen::Vector3d x_) -> double {
    double x = x_(0);
    double y = x_(1);
    double z = x_(2);
    return pow(k, 2) * (cos(z) + sin(x) + sin(y)) +
           (2 * x * cos(x) + 2 * y * cos(y) + pow(x, 2) * cos(z) +
            pow(y, 2) * cos(z) + pow(y, 2) * sin(x) + pow(z, 2) * sin(x) +
            pow(x, 2) * sin(y) + pow(z, 2) * sin(y) - 2 * z * sin(z)) /
               (pow(x, 2) + pow(y, 2) + pow(z, 2));
  };

  // Compute the element vec for the triangle
  const auto elem_vec_provider =
      projects::hldo_sphere::assemble::WhitneyTwoVectorProvider<double>(f);

  // Get solutions
  // the mesh (octacon) conatains 8 cells
  std::vector<Eigen::VectorXd> Aes(8);
  for (int i = 0; i < 8; i++) {
    const auto element = mesh->EntityByIndex(0, i);
    Aes[i] = elem_vec_provider.Eval(*element);
  }

  // Construct the analytically computed solutions with mathematica
  Eigen::VectorXd Ae_anal(8);
  // clang-format off
  Ae_anal << 2.5077355428475516,
             2.5077355428475516,
             0.1156740972976757,
             0.1156740972976757,
             -2.2763873482522,
             -2.2763873482522,
             0.11567409729767561,
             0.1156740972976757;
  // clang-format on
  // Assert that the two matrices are approximately equal
  for (int k = 0; k < 8; k++) {
    EXPECT_NEAR(Aes[k](0), Ae_anal[k], 1e-10)
        << "mismatch in entry (0) of triangle " << k;
  }
}

/**
 *
 * @brief Test the element matrix provider for the whitney one form mass matrix
 *
 * The whitney one form mass matrix the same as the matrix based on
 * the integral over the dotproduct of two rotated whitney one basis
 * functions.
 *
 * Test the element vector provider on the triangle
 * ((5,0,0), (1,1,0), (0,0,1))
 *
 * with relative edge orientations
 *
 * s_0 = 1, s_1 = -1, s_2 = -1
 *
 * And the linear form
 *
 * @f[
 *  \int_K\ \bm{u} \cdot \bm{v} \,\mathrm{d}x, \quad u, v \in
 * \bm{H}(curl_{\Gamma}, \partial\mathbb{S})
 * @f]
 *
 * Using the whitney one forms
 *
 * @note the matrix can as well be used for the rotated whitney one forms
 * instead of the whitney one forms
 *
 * For analytical solution see assemby.pdf
 *
 */
TEST(projects_hldo_sphere_assembly,
     whitney_one_mass_matrix_assembler_test_flat) {
  // Build Mesh
  const auto trig = lf::base::RefEl::kTria();
  const auto seg = lf::base::RefEl::kSegment();

  // Define Vertices
  Eigen::MatrixXd vertices(3, 3);
  // clang-format off
  vertices << 5, 1, 0,
              0, 1, 0,
              0, 0, 1;
  // clang-format on
  lf::mesh::hybrid2d::MeshFactory factory(3);
  factory.AddPoint(vertices.col(0));
  factory.AddPoint(vertices.col(1));
  factory.AddPoint(vertices.col(2));

  // Build Segments
  // First define directions
  std::vector<std::array<lf::mesh::MeshFactory::size_type, 2>> edge_nodes(3);
  edge_nodes[0] = {0, 1};
  edge_nodes[1] = {2, 1};
  edge_nodes[2] = {0, 2};

  // Build segments based on directions
  std::vector<Eigen::MatrixXd> edge_endpoints(3);
  std::vector<std::unique_ptr<lf::geometry::Geometry>> edge_geom(3);
  for (int i = 0; i < 3; i++) {
    edge_endpoints[i] = Eigen::MatrixXd::Zero(3, 2);
    edge_endpoints[i].col(0) = vertices.col(edge_nodes[i][0]);
    edge_endpoints[i].col(1) = vertices.col(edge_nodes[i][1]);
    edge_geom[i] = std::make_unique<lf::geometry::SegmentO1>(edge_endpoints[i]);
    factory.AddEntity(seg, nonstd::span(edge_nodes[i].data(), 2),
                      std::move(edge_geom[i]));
  }

  // build triangle
  std::unique_ptr<lf::geometry::Geometry> geom =
      std::make_unique<lf::geometry::TriaO1>(vertices);
  const std::array<lf::mesh::MeshFactory::size_type, 3> nodes = {0, 1, 2};
  factory.AddEntity(trig, nonstd::span(nodes.data(), 3), std::move(geom));

  const auto mesh = factory.Build();
  const auto element = mesh->EntityByIndex(0, 0);
  // Compute the element matrix for the triangle
  const auto elem_mat_provider =
      projects::hldo_sphere::assemble::WhitneyOneMassMatrixProvider();
  const Eigen::MatrixXd Ae = elem_mat_provider.Eval(*element);
  // Construct the analytically computed element matrix
  Eigen::MatrixXd Ae_anal(3, 3);

  // autogenerated mathematica
  Ae_anal << (5 * sqrt(1.1666666666666667)) / 12., 29 / (12. * sqrt(42)),
      -17 / (12. * sqrt(42)), 29 / (12. * sqrt(42)), sqrt(10.5) / 4.,
      -11 / (12. * sqrt(42)), -17 / (12. * sqrt(42)), -11 / (12. * sqrt(42)),
      17 / (12. * sqrt(42));
  // Assert that the two matrices are approximately equal
  ASSERT_EQ(Ae.rows(), Ae_anal.rows());
  ASSERT_EQ(Ae.cols(), Ae_anal.cols());
  for (int i = 0; i < Ae_anal.rows(); ++i) {
    for (int j = 0; j < Ae_anal.cols(); ++j) {
      EXPECT_DOUBLE_EQ(Ae(i, j), Ae_anal(i, j))
          << "mismatch in entry (" << i << ", " << j << ")";
    }
  }
}

/**
 *
 * @brief Test the element matrix provider for the whitney two form
 *
 * Test the element vector provider on the triangle
 * ((5,0,0), (1,1,0), (0,0,1))
 *
 * with relative edge orientations
 *
 * s_0 = 1, s_1 = -1, s_2 = -1
 *
 * And the linear form
 *
 * @f[
 *  \int_K\ div(u) v \,\mathrm{d}x, \quad \bm{u} \in
 * \bm{H}(div_{\Gamma}, \partial\mathbb{S})
 * v \in L^2(\partial \mathbb{S})
 * @f]
 *
 * Using the rotated whitney one forms for u and the whitney two forms for v
 *
 * For analytical solution see assemby.pdf
 *
 */
TEST(projects_hldo_sphere_assembly,
     rot_w_one_form_div_matrix_assembler_test_flat) {
  // Build Mesh
  const auto trig = lf::base::RefEl::kTria();
  const auto seg = lf::base::RefEl::kSegment();

  // Define Vertices
  Eigen::MatrixXd vertices(3, 3);
  // clang-format off
  vertices << 5, 1, 0,
              0, 1, 0,
              0, 0, 1;
  // clang-format on
  lf::mesh::hybrid2d::MeshFactory factory(3);
  factory.AddPoint(vertices.col(0));
  factory.AddPoint(vertices.col(1));
  factory.AddPoint(vertices.col(2));

  // Build Segments
  // First define directions
  std::vector<std::array<lf::mesh::MeshFactory::size_type, 2>> edge_nodes(3);
  edge_nodes[0] = {0, 1};
  edge_nodes[1] = {2, 1};
  edge_nodes[2] = {0, 2};

  // Build segments based on directions
  std::vector<Eigen::MatrixXd> edge_endpoints(3);
  std::vector<std::unique_ptr<lf::geometry::Geometry>> edge_geom(3);
  for (int i = 0; i < 3; i++) {
    edge_endpoints[i] = Eigen::MatrixXd::Zero(3, 2);
    edge_endpoints[i].col(0) = vertices.col(edge_nodes[i][0]);
    edge_endpoints[i].col(1) = vertices.col(edge_nodes[i][1]);
    edge_geom[i] = std::make_unique<lf::geometry::SegmentO1>(edge_endpoints[i]);
    factory.AddEntity(seg, nonstd::span(edge_nodes[i].data(), 2),
                      std::move(edge_geom[i]));
  }

  // build triangle
  std::unique_ptr<lf::geometry::Geometry> geom =
      std::make_unique<lf::geometry::TriaO1>(vertices);
  const std::array<lf::mesh::MeshFactory::size_type, 3> nodes = {0, 1, 2};
  factory.AddEntity(trig, nonstd::span(nodes.data(), 3), std::move(geom));

  const auto mesh = factory.Build();
  const auto element = mesh->EntityByIndex(0, 0);
  // Compute the element matrix for the triangle
  const auto elem_mat_provider =
      projects::hldo_sphere::assemble::RotWhitneyOneDivMatrixProvider();
  const Eigen::MatrixXd Ae = elem_mat_provider.Eval(*element);
  // Construct the analytically computed element matrix
  Eigen::MatrixXd Ae_anal(3, 1);
  // clang-format off
  Ae_anal <<  -1, 1, 1;
  // clang-format on
  // Assert that the two matrices are approximately equal
  ASSERT_EQ(Ae.rows(), Ae_anal.rows());
  ASSERT_EQ(Ae.cols(), Ae_anal.cols());
  for (int i = 0; i < Ae_anal.rows(); ++i) {
    EXPECT_DOUBLE_EQ(Ae(i), Ae_anal(i)) << "mismatch in entry (" << i << ")";
  }
}

/**
 *
 * @brief Test the element matrix provider for the whitney two mass matrix
 *
 * Test the element vector provider on the triangle
 * ((5,0,0), (1,1,0), (0,0,1))
 *
 * with relative edge orientations
 *
 * s_0 = 1, s_1 = -1, s_2 = -1
 *
 * And the linear form
 *
 * @f[
 *  \int_K\ u\ v \,\mathrm{d}x, \quad
 * u, v \in L^2(\partial \mathbb{S})
 * @f]
 *
 * Using the whitney two forms
 *
 * For analytical solution see assemby.pdf
 *
 */
TEST(projects_hldo_sphere_assembly,
     whitney_two_mass_matrix_assembler_test_flat) {
  // Build Mesh
  const auto trig = lf::base::RefEl::kTria();
  const auto seg = lf::base::RefEl::kSegment();

  // Define Vertices
  Eigen::MatrixXd vertices(3, 3);
  // clang-format off
  vertices << 5, 1, 0,
              0, 1, 0,
              0, 0, 1;
  // clang-format on
  lf::mesh::hybrid2d::MeshFactory factory(3);
  factory.AddPoint(vertices.col(0));
  factory.AddPoint(vertices.col(1));
  factory.AddPoint(vertices.col(2));

  // Build Segments
  // First define directions
  std::vector<std::array<lf::mesh::MeshFactory::size_type, 2>> edge_nodes(3);
  edge_nodes[0] = {0, 1};
  edge_nodes[1] = {2, 1};
  edge_nodes[2] = {0, 2};

  // Build segments based on directions
  std::vector<Eigen::MatrixXd> edge_endpoints(3);
  std::vector<std::unique_ptr<lf::geometry::Geometry>> edge_geom(3);
  for (int i = 0; i < 3; i++) {
    edge_endpoints[i] = Eigen::MatrixXd::Zero(3, 2);
    edge_endpoints[i].col(0) = vertices.col(edge_nodes[i][0]);
    edge_endpoints[i].col(1) = vertices.col(edge_nodes[i][1]);
    edge_geom[i] = std::make_unique<lf::geometry::SegmentO1>(edge_endpoints[i]);
    factory.AddEntity(seg, nonstd::span(edge_nodes[i].data(), 2),
                      std::move(edge_geom[i]));
  }

  // build triangle
  std::unique_ptr<lf::geometry::Geometry> geom =
      std::make_unique<lf::geometry::TriaO1>(vertices);
  const std::array<lf::mesh::MeshFactory::size_type, 3> nodes = {0, 1, 2};
  factory.AddEntity(trig, nonstd::span(nodes.data(), 3), std::move(geom));

  const auto mesh = factory.Build();
  const auto element = mesh->EntityByIndex(0, 0);
  // Compute the element matrix for the triangle
  const auto elem_mat_provider =
      projects::hldo_sphere::assemble::WhitneyTwoMassMatrixProvider();
  const Eigen::MatrixXd Ae = elem_mat_provider.Eval(*element);
  // Construct the analytically computed element matrix
  Eigen::MatrixXd Ae_anal = Eigen::MatrixXd::Ones(1, 1);
  Ae_anal *= sqrt(21. / 2.);
  // Assert that the two matrices are approximately equal
  ASSERT_EQ(Ae.rows(), Ae_anal.rows());
  ASSERT_EQ(Ae.cols(), Ae_anal.cols());
  EXPECT_DOUBLE_EQ(Ae(0), Ae_anal(0));
}

/**
 *
 * @brief Test the element vector provider for the two-form
 *
 * Test the element vector provider on the triangle
 * ((5,0,0), (1,1,0), (0,0,1))
 *
 * with relative edge orientations
 *
 * s_0 = 1, s_1 = -1, s_2 = -1
 *
 * And the linear form
 *
 * @f[
 *  \int_K\ f \cdot v \,\mathrm{d}x, \quad f, v \in H^1
 * @f]
 *
 * using the load function
 *
 * @f[
 *  f((x_0,x_1, x_2)) = \sin(x_1)
 * @f]
 *
 * And the cellwise constant basis functions
 *
 * For analytical solution see assemby.pdf
 */
TEST(projects_hldo_sphere_assembly, vector_provider_two_form_test_flat) {
  // Build Mesh
  const auto trig = lf::base::RefEl::kTria();
  const auto seg = lf::base::RefEl::kSegment();

  // Define Vertices
  Eigen::MatrixXd vertices(3, 3);
  // clang-format off
  vertices << 5, 1, 0,
              0, 1, 0,
              0, 0, 1;
  // clang-format on
  lf::mesh::hybrid2d::MeshFactory factory(3);
  factory.AddPoint(vertices.col(0));
  factory.AddPoint(vertices.col(1));
  factory.AddPoint(vertices.col(2));

  // Build Segments
  // First define directions
  std::vector<std::array<lf::mesh::MeshFactory::size_type, 2>> edge_nodes(3);
  edge_nodes[0] = {0, 1};
  edge_nodes[1] = {2, 1};
  edge_nodes[2] = {0, 2};

  // Build segments based on directions
  std::vector<Eigen::MatrixXd> edge_endpoints(3);
  std::vector<std::unique_ptr<lf::geometry::Geometry>> edge_geom(3);
  for (int i = 0; i < 3; i++) {
    edge_endpoints[i] = Eigen::MatrixXd::Zero(3, 2);
    edge_endpoints[i].col(0) = vertices.col(edge_nodes[i][0]);
    edge_endpoints[i].col(1) = vertices.col(edge_nodes[i][1]);
    edge_geom[i] = std::make_unique<lf::geometry::SegmentO1>(edge_endpoints[i]);
    factory.AddEntity(seg, nonstd::span(edge_nodes[i].data(), 2),
                      std::move(edge_geom[i]));
  }

  // Build triangle
  std::unique_ptr<lf::geometry::Geometry> geom =
      std::make_unique<lf::geometry::TriaO1>(vertices);
  const std::array<lf::mesh::MeshFactory::size_type, 3> nodes = {0, 1, 2};
  factory.AddEntity(trig, nonstd::span(nodes.data(), 3), std::move(geom));
  const auto mesh = factory.Build();

  // Define function f
  auto f = [&](const Eigen::Vector3d x) -> double { return sin(x(1)); };

  const auto element = mesh->EntityByIndex(0, 0);
  // Compute the element vec for the triangle
  const auto elem_vec_provider =
      projects::hldo_sphere::assemble::WhitneyTwoVectorProvider<double>(f);
  const Eigen::VectorXd Ae = elem_vec_provider.Eval(*element);
  // Construct the analytically computed element matrix
  Eigen::VectorXd Ae_anal(1);
  // clang-format off
  Ae_anal <<  sqrt(14. / 3.) * sin(0.5);
  // clang-format on
  // Assert that the two matrices are approximately equal
  ASSERT_EQ(Ae.rows(), Ae_anal.rows());
  ASSERT_EQ(Ae.cols(), Ae_anal.cols());
  EXPECT_DOUBLE_EQ(Ae(0), Ae_anal(0)) << "mismatch in entry (0)";
}
