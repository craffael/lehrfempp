<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.13.2" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LehrFEM++: Quick Reference - Mesh</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="clipboard.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "bm.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
// This file defines a number of macros which can be used in 
// formulas of the doxygen documentation.
MathJax.Hub.Config({
  jax: ["input/TeX", "output/CommonHTML", "output/HTML-CSS"],
  TeX: {
    extensions: ['AMSsymbols.js'],
    Macros: {
      vec: ["\\boldsymbol{#1}", 1],
      grad: "\\vec{\\operatorname{grad}}",
      norm: ["\\left\\lVert#1\\right\\rVert", 1]
    }
  }
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
  <!-- Doxygen Awesome Paragraph Link Extension-->
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
  </script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectlogo"><img alt="Logo" src="logo.gif"  /></td>
              <td id="projectalign">
                <div id="projectname">LehrFEM++<span
                    id="projectnumber">&#160;1.0.0</span>
                </div>
                <div id="projectbrief">A simple Finite Element Library for teaching</div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('quick_reference_mesh.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Quick Reference - Mesh</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1">
    <a href="#autotoc_md199">Overview</a>
  </li>
  <li class="level1">
    <a href="#mesh_access">Mesh Access</a>
  </li>
  <li class="level1">
    <a href="#entities">Entities</a>
  </li>
  <li class="level1">
    <a href="#mesh_data_sets">Mesh Data Sets</a>
  </li>
  <li class="level1">
    <a href="#mesh_functions">Mesh Functions</a>
    <ul>
      <li class="level2">
        <a href="#femf">Finite Element Mesh Functions</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#mesh_creation">Mesh Creation</a>
    <ul>
      <li class="level2">
        <a href="#mesh_refinement">Mesh Refinement</a>
      </li>
      <li class="level2">
        <a href="#mesh_builder">Mesh Builder</a>
      </li>
    </ul>
  </li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md__2home_2runner_2work_2lehrfempp_2lehrfempp_2doc_2doxygen_2pages_2quick__reference__mesh"></a></p>
<p><a href="https://github.com/craffael/lehrfempp/blob/master/doc/doxygen/pages/quick_reference_mesh.md" class="github_edit" title="Edit page on GitHub" target="_blank">Edit on GitHub</a></p>
<dl class="section attention"><dt>Attention</dt><dd>The contents of this page is discussed in <a href="https://www.sam.math.ethz.ch/~grsam/NUMPDEFL/NUMPDE.pdf#subsection.2.7.2" title="Mesh Information and Mesh Data Structures">Lecture Document Subsection 2.7.2</a>. Please read this section before using the quick reference.</dd></dl>
<h1><a class="anchor" id="autotoc_md199"></a>
Overview</h1>
<p>Meshes in LehrFEM++ are generally managed through shared pointers. A simple test mesh can be generated using the following code snippet:</p>
<div class="fragment"><div class="line"><span class="comment">// Generate a simple test mesh</span></div>
<div class="line"><span class="keyword">const</span> std::shared_ptr&lt;const lf::mesh::Mesh&gt; mesh_ptr =</div>
<div class="line">    <a class="code hl_function" href="namespacelf_1_1mesh_1_1test__utils.html#a4a99c0d4db0495121ff8ad0e63f889cb">lf::mesh::test_utils::GenerateHybrid2DTestMesh</a>(1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Auto can be used to simplify the type declaration</span></div>
<div class="line"><span class="keyword">auto</span> mesh_ptr = <a class="code hl_function" href="namespacelf_1_1mesh_1_1test__utils.html#a4a99c0d4db0495121ff8ad0e63f889cb">lf::mesh::test_utils::GenerateHybrid2DTestMesh</a>(1);</div>
<div class="ttc" id="anamespacelf_1_1mesh_1_1test__utils_html_a4a99c0d4db0495121ff8ad0e63f889cb"><div class="ttname"><a href="namespacelf_1_1mesh_1_1test__utils.html#a4a99c0d4db0495121ff8ad0e63f889cb">lf::mesh::test_utils::GenerateHybrid2DTestMesh</a></div><div class="ttdeci">std::shared_ptr&lt; lf::mesh::Mesh &gt; GenerateHybrid2DTestMesh(int selector, double scale)</div><div class="ttdoc">Generates a simple 2D hybrid test mesh.</div><div class="ttdef"><b>Definition</b> <a href="test__meshes_8cc_source.html#l00014">test_meshes.cc:14</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="mesh_access"></a>
Mesh Access</h1>
<div class="fragment"><div class="line"><span class="comment">// create a pointer to the mesh</span></div>
<div class="line"><span class="keyword">const</span> std::shared_ptr&lt;const lf::mesh::Mesh&gt; mesh_p = <a class="code hl_function" href="namespacelf_1_1mesh_1_1test__utils.html#a4a99c0d4db0495121ff8ad0e63f889cb">lf::mesh::test_utils::GenerateHybrid2DTestMesh</a>(1);</div>
</div><!-- fragment --><p>The mesh object can be accessed through the pointer <code>mesh_p</code> (will be used throughout this page). The mesh object provides access to the following information:</p>
<div class="fragment"><div class="line"><span class="comment">// Access number of cells</span></div>
<div class="line"><span class="keywordtype">unsigned</span> num_entities = mesh_p-&gt;NumEntities(0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Access number of edges</span></div>
<div class="line"><span class="keywordtype">unsigned</span> num_nodes = mesh_p-&gt;NumEntities(1);</div>
</div><!-- fragment --><h1><a class="anchor" id="entities"></a>
Entities</h1>
<p>Entities implement the <a class="el" href="classlf_1_1mesh_1_1_entity.html" title="Interface class representing a topological entity in a cellular complex">lf::mesh::Entity</a> interface and are the building blocks of a mesh. LehrFEM++ provides a number of different types of entities:</p>
<ul>
<li><b>Triangles</b> <a class="el" href="classlf_1_1mesh_1_1hybrid2d_1_1_triangle.html" title="Describes a trilateral cell for a 2D hybrid mesh.">lf::mesh::hybrid2d::Triangle</a></li>
<li><b>Quadrilaterals</b> <a class="el" href="classlf_1_1mesh_1_1hybrid2d_1_1_quadrilateral.html" title="Describes a general quadrilateral cell for a 2D hybrid mesh.">lf::mesh::hybrid2d::Quadrilateral</a></li>
<li><b>Segments</b> <a class="el" href="classlf_1_1mesh_1_1hybrid2d_1_1_segment.html" title="An edge object for a 2D hybrid mesh.">lf::mesh::hybrid2d::Segment</a></li>
<li><b>Points</b> <a class="el" href="classlf_1_1mesh_1_1hybrid2d_1_1_point.html" title="A node object for a 2D hybrid mesh.">lf::mesh::hybrid2d::Point</a></li>
</ul>
<p>A complete list can be found in the inheritance diagram of the <a class="el" href="classlf_1_1mesh_1_1_entity.html" title="Interface class representing a topological entity in a cellular complex">lf::mesh::Entity</a> interface class. Entities can be accessed by index or by iterating over all entities of a given co-dimension.</p>
<div class="fragment"><div class="line"><span class="comment">// Get entity pointer by index from a mesh</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classlf_1_1mesh_1_1_entity.html">lf::mesh::Entity</a>* entity = mesh_p-&gt;EntityByIndex(0, 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Iterate over all entities of co-dimension 0 (cells)</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_class" href="classlf_1_1mesh_1_1_entity.html">lf::mesh::Entity</a>* cell : mesh_p-&gt;Entities(0)) {</div>
<div class="line">    <span class="comment">// Do something with entity e.g.: print index of cell</span></div>
<div class="line">    std::cout &lt;&lt; mesh_p-&gt;Index(*cell) &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclasslf_1_1mesh_1_1_entity_html"><div class="ttname"><a href="classlf_1_1mesh_1_1_entity.html">lf::mesh::Entity</a></div><div class="ttdoc">Interface class representing a topological entity in a cellular complex</div><div class="ttdef"><b>Definition</b> <a href="entity_8h_source.html#l00042">entity.h:42</a></div></div>
</div><!-- fragment --><p>Entities have a number of properties that can be accessed:</p>
<div class="fragment"><div class="line"><span class="comment">// Get the co-dimension of the entity</span></div>
<div class="line"><span class="keywordtype">unsigned</span> codim = entity-&gt;<a class="code hl_function" href="classlf_1_1mesh_1_1_entity.html#a6a5c3a701df8c631e5377704267fb208">Codim</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the geometry of the entity, more details can be found </span></div>
<div class="line"><span class="comment">// in the Geometry Quick reference</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classlf_1_1geometry_1_1_geometry.html">lf::geometry::Geometry</a>* geometry = entity-&gt;<a class="code hl_function" href="classlf_1_1mesh_1_1_entity.html#a7e38f16a9723f82a1ea06cc3ac3aa3f1">Geometry</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the reference element of the entity (e.g. the unit triangle for a general triangle)</span></div>
<div class="line"><a class="code hl_class" href="classlf_1_1base_1_1_ref_el.html">lf::base::RefEl</a> ref_el = entity-&gt;<a class="code hl_function" href="classlf_1_1mesh_1_1_entity.html#acff29c2e4f65daaef0152b07559b3f52">RefEl</a>();</div>
<div class="ttc" id="aclasslf_1_1base_1_1_ref_el_html"><div class="ttname"><a href="classlf_1_1base_1_1_ref_el.html">lf::base::RefEl</a></div><div class="ttdoc">Represents a reference element with all its properties.</div><div class="ttdef"><b>Definition</b> <a href="ref__el_8h_source.html#l00109">ref_el.h:109</a></div></div>
<div class="ttc" id="aclasslf_1_1geometry_1_1_geometry_html"><div class="ttname"><a href="classlf_1_1geometry_1_1_geometry.html">lf::geometry::Geometry</a></div><div class="ttdoc">Interface class for shape information on a mesh cell in the spirit of parametric finite element metho...</div><div class="ttdef"><b>Definition</b> <a href="geometry__interface_8h_source.html#l00021">geometry_interface.h:21</a></div></div>
<div class="ttc" id="aclasslf_1_1mesh_1_1_entity_html_a6a5c3a701df8c631e5377704267fb208"><div class="ttname"><a href="classlf_1_1mesh_1_1_entity.html#a6a5c3a701df8c631e5377704267fb208">lf::mesh::Entity::Codim</a></div><div class="ttdeci">virtual unsigned Codim() const =0</div><div class="ttdoc">The codimension of this entity w.r.t. the Mesh.dimMesh() of the owning mesh manager.</div></div>
<div class="ttc" id="aclasslf_1_1mesh_1_1_entity_html_a7e38f16a9723f82a1ea06cc3ac3aa3f1"><div class="ttname"><a href="classlf_1_1mesh_1_1_entity.html#a7e38f16a9723f82a1ea06cc3ac3aa3f1">lf::mesh::Entity::Geometry</a></div><div class="ttdeci">virtual const geometry::Geometry * Geometry() const =0</div><div class="ttdoc">Describes the geometry of this entity.</div></div>
<div class="ttc" id="aclasslf_1_1mesh_1_1_entity_html_acff29c2e4f65daaef0152b07559b3f52"><div class="ttname"><a href="classlf_1_1mesh_1_1_entity.html#acff29c2e4f65daaef0152b07559b3f52">lf::mesh::Entity::RefEl</a></div><div class="ttdeci">virtual base::RefEl RefEl() const =0</div><div class="ttdoc">Describes the reference element type of this entity.</div></div>
</div><!-- fragment --><p>It is also possible to access sub-entities of an entity, see <a class="el" href="classlf_1_1mesh_1_1_entity.html#a23b6ce2f785146482606c9bc73f4f09f" title="Return all sub entities of this entity that have the given codimension (w.r.t. this entity!...">lf::mesh::Entity::SubEntities</a> for details.</p>
<div class="fragment"><div class="line"><span class="comment">// Return all sub entities of this entity that have the given </span></div>
<div class="line"><span class="comment">// co-dimension (w.r.t. this entity!)</span></div>
<div class="line"><span class="comment">// For example, for a cell, the sub-entities of co-dimension 1</span></div>
<div class="line">std::span&lt;const lf::mesh::Entity* const&gt; sub_entities =</div>
<div class="line">      entity-&gt;<a class="code hl_function" href="classlf_1_1mesh_1_1_entity.html#a23b6ce2f785146482606c9bc73f4f09f">SubEntities</a>(1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// If you require a vector of sub-entities, you can use the following code snippet</span></div>
<div class="line">std::vector&lt;const lf::mesh::Entity*&gt; sub_entities_vec{</div>
<div class="line">    entity-&gt;<a class="code hl_function" href="classlf_1_1mesh_1_1_entity.html#a23b6ce2f785146482606c9bc73f4f09f">SubEntities</a>(1).begin(), entity-&gt;<a class="code hl_function" href="classlf_1_1mesh_1_1_entity.html#a23b6ce2f785146482606c9bc73f4f09f">SubEntities</a>(1).end()};</div>
<div class="ttc" id="aclasslf_1_1mesh_1_1_entity_html_a23b6ce2f785146482606c9bc73f4f09f"><div class="ttname"><a href="classlf_1_1mesh_1_1_entity.html#a23b6ce2f785146482606c9bc73f4f09f">lf::mesh::Entity::SubEntities</a></div><div class="ttdeci">virtual std::span&lt; const Entity *const &gt; SubEntities(unsigned rel_codim) const =0</div><div class="ttdoc">Return all sub entities of this entity that have the given codimension (w.r.t. this entity!...</div></div>
</div><!-- fragment --><p>A slightly more nuanced concept is the relative orientation of sub-entities of the next higher co-dimension. A detailed explanation can be found in the <a href="https://www.sam.math.ethz.ch/~grsam/NUMPDEFL/NUMPDE.pdf#page=210" title="\lfpp Mesh: Topology Layer">Lecture Document Remark 2.7.2.15</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// return span of relative orientations of sub-entities of the next higher co-dimension.</span></div>
<div class="line">std::span&lt;const lf::mesh::Orientation&gt; orientations =</div>
<div class="line">      entity-&gt;<a class="code hl_function" href="classlf_1_1mesh_1_1_entity.html#a603ca86bf701aa3b1984ecfb06586f3a">RelativeOrientations</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// If you require a vector of orientations, you can use the following code snippet</span></div>
<div class="line">std::vector&lt;lf::mesh::Orientation&gt; orientations_vec{</div>
<div class="line">      entity-&gt;<a class="code hl_function" href="classlf_1_1mesh_1_1_entity.html#a603ca86bf701aa3b1984ecfb06586f3a">RelativeOrientations</a>().begin(),</div>
<div class="line">      entity-&gt;<a class="code hl_function" href="classlf_1_1mesh_1_1_entity.html#a603ca86bf701aa3b1984ecfb06586f3a">RelativeOrientations</a>().end()};</div>
<div class="ttc" id="aclasslf_1_1mesh_1_1_entity_html_a603ca86bf701aa3b1984ecfb06586f3a"><div class="ttname"><a href="classlf_1_1mesh_1_1_entity.html#a603ca86bf701aa3b1984ecfb06586f3a">lf::mesh::Entity::RelativeOrientations</a></div><div class="ttdeci">virtual std::span&lt; const Orientation &gt; RelativeOrientations() const =0</div><div class="ttdoc">return span of relative orientations of sub-entities of the next higher co-dimension.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="mesh_data_sets"></a>
Mesh Data Sets</h1>
<p>Mesh data sets are used to store data with entities of the mesh. A fe common use cases are:</p>
<ul>
<li>Flags that mark boundary entities.</li>
<li>Material parameters for mesh elements (codim=0)</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Create a mesh data set storing boolean values for each entity</span></div>
<div class="line"><a class="code hl_class" href="classlf_1_1mesh_1_1utils_1_1_all_codim_mesh_data_set.html">lf::mesh::utils::AllCodimMeshDataSet&lt;bool&gt;</a> mesh_data_set =</div>
<div class="line">      <a class="code hl_class" href="classlf_1_1mesh_1_1utils_1_1_all_codim_mesh_data_set.html">lf::mesh::utils::AllCodimMeshDataSet&lt;bool&gt;</a>(mesh_p);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a MDS storing boolean values for each entity of co-dimension 1 (edges)</span></div>
<div class="line"><a class="code hl_class" href="classlf_1_1mesh_1_1utils_1_1_codim_mesh_data_set.html">lf::mesh::utils::CodimMeshDataSet&lt;bool&gt;</a> mesh_data_set_edges =</div>
<div class="line">      <a class="code hl_class" href="classlf_1_1mesh_1_1utils_1_1_codim_mesh_data_set.html">lf::mesh::utils::CodimMeshDataSet&lt;bool&gt;</a>(mesh_p, 1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Mesh data sets can be initialized with a default value</span></div>
<div class="line"><a class="code hl_class" href="classlf_1_1mesh_1_1utils_1_1_all_codim_mesh_data_set.html">lf::mesh::utils::AllCodimMeshDataSet&lt;bool&gt;</a> mesh_data_set_2 =</div>
<div class="line">      <a class="code hl_class" href="classlf_1_1mesh_1_1utils_1_1_all_codim_mesh_data_set.html">lf::mesh::utils::AllCodimMeshDataSet&lt;bool&gt;</a>(mesh_p, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Access a (modifiable) value associated with an entity</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classlf_1_1mesh_1_1_entity.html">lf::mesh::Entity</a>* entity = mesh_p-&gt;EntityByIndex(0, 0);</div>
<div class="line"><span class="keywordtype">bool</span> value = mesh_data_set(*entity);</div>
<div class="ttc" id="aclasslf_1_1mesh_1_1utils_1_1_all_codim_mesh_data_set_html"><div class="ttname"><a href="classlf_1_1mesh_1_1utils_1_1_all_codim_mesh_data_set.html">lf::mesh::utils::AllCodimMeshDataSet</a></div><div class="ttdoc">Assigns to every entity (all codims) in a mesh a value of type T</div><div class="ttdef"><b>Definition</b> <a href="all__codim__mesh__data__set_8h_source.html#l00038">all_codim_mesh_data_set.h:38</a></div></div>
<div class="ttc" id="aclasslf_1_1mesh_1_1utils_1_1_codim_mesh_data_set_html"><div class="ttname"><a href="classlf_1_1mesh_1_1utils_1_1_codim_mesh_data_set.html">lf::mesh::utils::CodimMeshDataSet</a></div><div class="ttdoc">A MeshDataSet that attaches data of type T to every entity of a mesh that has a specified codimension...</div><div class="ttdef"><b>Definition</b> <a href="codim__mesh__data__set_8h_source.html#l00028">codim_mesh_data_set.h:28</a></div></div>
</div><!-- fragment --><p>In this example, a mesh data set is created that stores boolean values for each entity/edge of the mesh.</p>
<p>To flag all entities on the boundary of the mesh, the following code snippet can be used:</p>
<div class="fragment"><div class="line"><span class="comment">// Create MeshDataSet storing boolean values for each entity indicating if the entity is on the boundary</span></div>
<div class="line"><a class="code hl_class" href="classlf_1_1mesh_1_1utils_1_1_all_codim_mesh_data_set.html">lf::mesh::utils::AllCodimMeshDataSet&lt;bool&gt;</a> bd_flags{</div>
<div class="line">      <a class="code hl_function" href="namespacelf_1_1mesh_1_1utils.html#a8b5d673cc329a83aabf29e965c727948">lf::mesh::utils::flagEntitiesOnBoundary</a>(mesh_p)};</div>
<div class="ttc" id="anamespacelf_1_1mesh_1_1utils_html_a8b5d673cc329a83aabf29e965c727948"><div class="ttname"><a href="namespacelf_1_1mesh_1_1utils.html#a8b5d673cc329a83aabf29e965c727948">lf::mesh::utils::flagEntitiesOnBoundary</a></div><div class="ttdeci">CodimMeshDataSet&lt; bool &gt; flagEntitiesOnBoundary(const std::shared_ptr&lt; const Mesh &gt; &amp;mesh_p, lf::base::dim_t codim)</div><div class="ttdoc">flag entities of a specific co-dimension located on the boundary</div><div class="ttdef"><b>Definition</b> <a href="special__entity__sets_8cc_source.html#l00040">special_entity_sets.cc:40</a></div></div>
</div><!-- fragment --><p>See also <a class="el" href="quick_reference_bc.html">Quick Reference - Boundary Conditions</a> for more details on boundary conditions.</p>
<p>The interface is defined in the lf::mesh::MeshDataSet class. More details can be found in the documentation of the lf::mesh::MeshDataSet class.</p>
<h1><a class="anchor" id="mesh_functions"></a>
Mesh Functions</h1>
<p>Mesh functions are wrappers around a functor that can be evaluated on the entire mesh. The interface is defined in <a class="el" href="conceptlf_1_1mesh_1_1utils_1_1_mesh_function.html" title="A MeshFunction is a function object that can be evaluated at any point on the mesh.">lf::mesh::utils::MeshFunction</a>. A more detailed definition can be found in the <a href="https://www.sam.math.ethz.ch/~grsam/NUMPDEFL/NUMPDE.pdf#equation.2.8.32" title="Transformation Techniques">Lecture Document supplement 2.8.3.32</a>.</p>
<p>The most general representative of a mesh function is <a class="el" href="classlf_1_1mesh_1_1utils_1_1_mesh_function_global.html" title="MeshFunction wrapper for a simple function of physical coordinates.">lf::mesh::utils::MeshFunctionGlobal</a>. It takes a functor that can be evaluated on the entire mesh. The functor must provide an operator() which takes a point within the entity reference Element and returns a value. Lambda functions are a common way to define such functors.</p>
<p>For efficiency reasons the evaluation points are passed to mesh functions as the columns of a \(d \times n \) - matrix (where \(d\) agrees with the local dimension of the entity and \(n\) is the number of points). This allows for the evaluation of multiple points at once. The following code snippet demonstrates how to define a mesh function that evaluates the function</p>
<p class="formulaDsp">
\[    \alpha(x) = 0.5 \cdot \|x\|
\]
</p>
<p>on a cell.</p>
<div class="fragment"><div class="line"><span class="comment">// Define a lambda function that takes a point in the reference element of an entity and returns a value</span></div>
<div class="line"><span class="keyword">auto</span> alpha = [](Eigen::Vector2d x) -&gt; <span class="keywordtype">double</span> {</div>
<div class="line">    <span class="keywordflow">return</span> 0.5 * x.norm();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wrap the lambda function in a MeshFunctionGlobal object</span></div>
<div class="line"><span class="comment">// Type of mesh function template parameter is automatically deduced</span></div>
<div class="line"><a class="code hl_class" href="classlf_1_1mesh_1_1utils_1_1_mesh_function_global.html">lf::mesh::utils::MeshFunctionGlobal</a> mesh_function = <a class="code hl_class" href="classlf_1_1mesh_1_1utils_1_1_mesh_function_global.html">lf::mesh::utils::MeshFunctionGlobal</a>(alpha);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Evaluate the mesh function on a cell</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classlf_1_1mesh_1_1_entity.html">lf::mesh::Entity</a>* cell = mesh_p-&gt;EntityByIndex(0, 0);</div>
<div class="line">std::vector&lt;double&gt; values = mesh_function(*cell, Eigen::Vector2d{0.5, 0.5});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// We only asked for one point, so the vector has only one entry</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Value: &quot;</span> &lt;&lt; values[0] &lt;&lt; std::endl; <span class="comment">// Value: 0.790569</span></div>
<div class="ttc" id="aclasslf_1_1mesh_1_1utils_1_1_mesh_function_global_html"><div class="ttname"><a href="classlf_1_1mesh_1_1utils_1_1_mesh_function_global.html">lf::mesh::utils::MeshFunctionGlobal</a></div><div class="ttdoc">MeshFunction wrapper for a simple function of physical coordinates.</div><div class="ttdef"><b>Definition</b> <a href="mesh__function__global_8h_source.html#l00055">mesh_function_global.h:55</a></div></div>
</div><!-- fragment --><p>There are is also a short-hand for mesh functions that are constant everywhere on the mesh: <a class="el" href="classlf_1_1mesh_1_1utils_1_1_mesh_function_constant.html" title="A MeshFunction which takes the same constant value on the whole mesh.">lf::mesh::utils::MeshFunctionConstant</a>.</p>
<p>MeshFunction objects support binary arithmetic operations +,-, and *, including scalar multiplication, provided that such operations are possible for their underlying types. As well as unary operations such as -, transpose(), and squaredNorm().</p>
<h2><a class="anchor" id="femf"></a>
Finite Element Mesh Functions</h2>
<p>A special case of mesh functions are finite element mesh functions. They are used to represent the solution of a finite element problem on a mesh.</p>
<ul>
<li><a class="el" href="classlf_1_1fe_1_1_mesh_function_f_e.html" title="A MeshFunction representing an element from a ScalarFESpace (e.g. solution of BVP)">lf::fe::MeshFunctionFE</a></li>
<li><a class="el" href="classlf_1_1fe_1_1_mesh_function_grad_f_e.html" title="A MeshFunction representing the gradient of a function from a scalar finite element space (e....">lf::fe::MeshFunctionGradFE</a></li>
</ul>
<h1><a class="anchor" id="mesh_creation"></a>
Mesh Creation</h1>
<p>The standard ways to create a Mesh object are:</p>
<ol type="1">
<li><b>Direct generation</b> via the <a class="el" href="classlf_1_1mesh_1_1_mesh_factory.html#ad2a8c08ecd944f951ecd120ec3ea642a" title="Construct a mesh out of the specified nodes and elements.">lf::mesh::MeshFactory::Build()</a> method. (This method is mainly used internally by LehrFEM++). Details can be found in the documentation of the <a class="el" href="classlf_1_1mesh_1_1_mesh_factory.html" title="Interface class for initialization of a mesh object.">lf::mesh::MeshFactory</a> class. A brief example is outlined below.</li>
<li><p class="startli"><b>Calling LehrFEM++'s generator of test meshes</b> <a class="el" href="namespacelf_1_1mesh_1_1test__utils.html#a4a99c0d4db0495121ff8ad0e63f889cb" title="Generates a simple 2D hybrid test mesh.">lf::mesh::test_utils::GenerateHybrid2DTestMesh()</a>. The method provides access to a number of simple predefined test meshes. The following code snippet demonstrates how to generate a simple test mesh:</p>
<div class="fragment"><div class="line"><span class="comment">// Generate a simple test mesh</span></div>
<div class="line">std::shared_ptr&lt;lf::mesh::Mesh&gt; mesh_p = <a class="code hl_function" href="namespacelf_1_1mesh_1_1test__utils.html#a4a99c0d4db0495121ff8ad0e63f889cb">lf::mesh::test_utils::GenerateHybrid2DTestMesh</a>(1);</div>
</div><!-- fragment --></li>
<li><p class="startli"><b>Reading a mesh from file</b>: see <a class="el" href="classlf_1_1io_1_1_gmsh_reader.html" title="Reads a Gmsh *.msh file into a mesh::MeshFactory and provides a link between mesh::Entity objects and...">lf::io::GmshReader</a>, and invoking <a class="el" href="classlf_1_1io_1_1_gmsh_reader.html#a724a4b18fbba112aad1578a36d433190" title="Get the mesh that was read by this reader.">lf::io::GmshReader::mesh()</a>. The following code snippet demonstrates how to read a mesh from a file:</p>
<div class="fragment"><div class="line"><span class="comment">// Read a mesh from a file</span></div>
<div class="line">std::unique_ptr&lt;lf::mesh::hybrid2d::MeshFactory&gt; mesh_factory =</div>
<div class="line">  std::make_unique&lt;lf::mesh::hybrid2d::MeshFactory&gt;(2);</div>
<div class="line"><a class="code hl_class" href="classlf_1_1io_1_1_gmsh_reader.html">lf::io::GmshReader</a> gmsh_reader =</div>
<div class="line">    <a class="code hl_class" href="classlf_1_1io_1_1_gmsh_reader.html">lf::io::GmshReader</a>(std::move(mesh_factory), <span class="stringliteral">&quot;triangle.msh&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get pointer to the mesh</span></div>
<div class="line">std::shared_ptr&lt;lf::mesh::Mesh&gt; mesh = gmsh_reader.<a class="code hl_function" href="classlf_1_1io_1_1_gmsh_reader.html#a724a4b18fbba112aad1578a36d433190">mesh</a>();</div>
<div class="ttc" id="aclasslf_1_1io_1_1_gmsh_reader_html"><div class="ttname"><a href="classlf_1_1io_1_1_gmsh_reader.html">lf::io::GmshReader</a></div><div class="ttdoc">Reads a Gmsh *.msh file into a mesh::MeshFactory and provides a link between mesh::Entity objects and...</div><div class="ttdef"><b>Definition</b> <a href="gmsh__reader_8h_source.html#l00070">gmsh_reader.h:70</a></div></div>
<div class="ttc" id="aclasslf_1_1io_1_1_gmsh_reader_html_a724a4b18fbba112aad1578a36d433190"><div class="ttname"><a href="classlf_1_1io_1_1_gmsh_reader.html#a724a4b18fbba112aad1578a36d433190">lf::io::GmshReader::mesh</a></div><div class="ttdeci">std::shared_ptr&lt; mesh::Mesh &gt; mesh()</div><div class="ttdoc">Get the mesh that was read by this reader.</div><div class="ttdef"><b>Definition</b> <a href="gmsh__reader_8h_source.html#l00079">gmsh_reader.h:79</a></div></div>
</div><!-- fragment --></li>
<li><b>Refining an existing mesh</b>, see <a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html" title="A hierarchy of nested 2D hybrid meshes created by refinement.">lf::refinement::MeshHierarchy</a> or the short example below.</li>
</ol>
<h2><a class="anchor" id="mesh_refinement"></a>
Mesh Refinement</h2>
<p>LehrFEM++ provides a number of mesh refinement tools included in the <a class="el" href="namespacelf_1_1refinement.html" title="tools for regular or local refinement of 2D hybrid meshes">lf::refinement</a> namespace.</p>
<p>Mesh refinement using LehrFEM++ is covered in <a href="https://www.sam.math.ethz.ch/~grsam/NUMPDEFL/NUMPDE.pdf#subsection.3.1.4" title="Refinement">Lecture Document Subsection 3.1.4</a> and heavily used in <a href="https://www.sam.math.ethz.ch/~grsam/NUMPDEFL/NUMPDE.pdf#chapter.3" title="FEM: Convergence and Accuracy">Lecture Document Chapter 3</a>.</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;lf::mesh::Mesh&gt; mesh_p = <a class="code hl_function" href="namespacelf_1_1mesh_1_1test__utils.html#a4a99c0d4db0495121ff8ad0e63f889cb">lf::mesh::test_utils::GenerateHybrid2DTestMesh</a>(0);</div>
<div class="line"><span class="comment">// Generate mesh hierarchy by uniform refinement with 6 levels</span></div>
<div class="line"> </div>
<div class="line">std::shared_ptr&lt;lf::refinement::MeshHierarchy&gt; mesh_seq_p{</div>
<div class="line">    <a class="code hl_function" href="namespacelf_1_1refinement.html#a1455c9eda57af2531db1e65d3b6951a1">lf::refinement::GenerateMeshHierarchyByUniformRefinemnt</a>(mesh_p, 3)};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Access the mesh at level 3</span></div>
<div class="line">std::shared_ptr&lt;lf::mesh::Mesh&gt; mesh_level_3 = mesh_seq_p-&gt;getMesh(3);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// We can refine a mesh further by calling</span></div>
<div class="line">mesh_seq_p-&gt;RefineRegular();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Access the mesh at level 4</span></div>
<div class="line">std::shared_ptr&lt;lf::mesh::Mesh&gt; mesh_level_4 = mesh_seq_p-&gt;getMesh(4);</div>
<div class="ttc" id="anamespacelf_1_1refinement_html_a1455c9eda57af2531db1e65d3b6951a1"><div class="ttname"><a href="namespacelf_1_1refinement.html#a1455c9eda57af2531db1e65d3b6951a1">lf::refinement::GenerateMeshHierarchyByUniformRefinemnt</a></div><div class="ttdeci">std::shared_ptr&lt; MeshHierarchy &gt; GenerateMeshHierarchyByUniformRefinemnt(const std::shared_ptr&lt; lf::mesh::Mesh &gt; &amp;mesh_p, lf::base::size_type ref_lev, RefPat ref_pat)</div><div class="ttdoc">Generated a sequence of nested 2D hybrid mehes by regular or barycentric refinement.</div><div class="ttdef"><b>Definition</b> <a href="mesh__hierarchy_8cc_source.html#l01917">mesh_hierarchy.cc:1917</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="mesh_builder"></a>
Mesh Builder</h2>
<p>Meshes can be built 'manually' using the <a class="el" href="classlf_1_1mesh_1_1_mesh_factory.html" title="Interface class for initialization of a mesh object.">lf::mesh::MeshFactory</a> class. It follows a <a href="https://refactoring.guru/design-patterns/builder">builder pattern</a> and allows the user to add entities to the mesh.</p>
<div class="fragment"><div class="line"><span class="comment">// builder for a hybrid mesh in a world of dimension 2</span></div>
<div class="line">std::shared_ptr&lt;lf::mesh::hybrid2d::MeshFactory&gt; mesh_factory =</div>
<div class="line">    std::make_shared&lt;lf::mesh::hybrid2d::MeshFactory&gt;(2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add points (needs to be done before adding entities)</span></div>
<div class="line">mesh_factory-&gt;AddPoint(Eigen::Vector2d{0, 0});    <span class="comment">// (0)</span></div>
<div class="line">mesh_factory-&gt;AddPoint(Eigen::Vector2d{1, 0});    <span class="comment">// (1)</span></div>
<div class="line">mesh_factory-&gt;AddPoint(Eigen::Vector2d{1, 1});    <span class="comment">// (2)</span></div>
<div class="line">mesh_factory-&gt;AddPoint(Eigen::Vector2d{0, 1});    <span class="comment">// (3)</span></div>
<div class="line">mesh_factory-&gt;AddPoint(Eigen::Vector2d{0.5, 1});  <span class="comment">// (4)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add a triangle</span></div>
<div class="line"><span class="comment">// First set the coordinates of its nodes:</span></div>
<div class="line">Eigen::MatrixXd nodesOfTria(2, 3);</div>
<div class="line">nodesOfTria &lt;&lt; 1, 1, 0.5, 0, 1, 1;</div>
<div class="line">mesh_factory-&gt;AddEntity(</div>
<div class="line">    <a class="code hl_function" href="classlf_1_1base_1_1_ref_el.html#ac6542f1b3d68028bc0bd8d9a223b35ff">lf::base::RefEl::kTria</a>(),  <span class="comment">// we want a triangle</span></div>
<div class="line">    std::array&lt;lf::mesh::Mesh::size_type, 3&gt;{</div>
<div class="line">        {1, 2, 4}},  <span class="comment">// indices of the nodes</span></div>
<div class="line">    std::make_unique&lt;lf::geometry::TriaO1&gt;(nodesOfTria));  <span class="comment">// node coords</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add a quadrilateral</span></div>
<div class="line">Eigen::MatrixXd nodesOfQuad(2, 4);</div>
<div class="line">nodesOfQuad &lt;&lt; 0, 1, 0.5, 0, 0, 0, 1, 1;</div>
<div class="line">mesh_factory-&gt;AddEntity(</div>
<div class="line">    <a class="code hl_function" href="classlf_1_1base_1_1_ref_el.html#ae28ad009a99541ecd2ab24999aebcf63">lf::base::RefEl::kQuad</a>(), <span class="comment">// we want a quadrilateral</span></div>
<div class="line">    std::array&lt;lf::mesh::Mesh::size_type, 4&gt;{</div>
<div class="line">        {0, 1, 4, 3}}, <span class="comment">// indices of the nodes</span></div>
<div class="line">    std::make_unique&lt;lf::geometry::QuadO1&gt;(nodesOfQuad)); <span class="comment">// node coords</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Build the mesh</span></div>
<div class="line">std::shared_ptr&lt;lf::mesh::Mesh&gt; mesh = mesh_factory-&gt;Build();</div>
<div class="ttc" id="aclasslf_1_1base_1_1_ref_el_html_ac6542f1b3d68028bc0bd8d9a223b35ff"><div class="ttname"><a href="classlf_1_1base_1_1_ref_el.html#ac6542f1b3d68028bc0bd8d9a223b35ff">lf::base::RefEl::kTria</a></div><div class="ttdeci">static constexpr RefEl kTria()</div><div class="ttdoc">Returns the reference triangle.</div><div class="ttdef"><b>Definition</b> <a href="ref__el_8h_source.html#l00161">ref_el.h:161</a></div></div>
<div class="ttc" id="aclasslf_1_1base_1_1_ref_el_html_ae28ad009a99541ecd2ab24999aebcf63"><div class="ttname"><a href="classlf_1_1base_1_1_ref_el.html#ae28ad009a99541ecd2ab24999aebcf63">lf::base::RefEl::kQuad</a></div><div class="ttdeci">static constexpr RefEl kQuad()</div><div class="ttdoc">Returns the reference quadrilateral.</div><div class="ttdef"><b>Definition</b> <a href="ref__el_8h_source.html#l00169">ref_el.h:169</a></div></div>
</div><!-- fragment --><p>We can also use the mesh builder to create a tensor product mesh. LehrFEM++ provides a number of mesh builders for different types of meshes.</p>
<ul>
<li><b><a class="el" href="classlf_1_1mesh_1_1utils_1_1_t_p_triag_mesh_builder.html" title="Implements a MeshBuilder that generates a triangular structured mesh.">lf::mesh::utils::TPTriagMeshBuilder</a></b> for a tensor product mesh of triangles.</li>
<li><b><a class="el" href="classlf_1_1mesh_1_1utils_1_1_t_p_quad_mesh_builder.html" title="Implements a Builder for a tensor product grid (with rectangular cells)">lf::mesh::utils::TPQuadMeshBuilder</a></b> for a tensor product mesh of quadrilaterals.</li>
<li><b><a class="el" href="classlf_1_1mesh_1_1utils_1_1_torus_mesh_builder.html" title="Implements a MeshBuilder for a tensor product grid of a torus.">lf::mesh::utils::TorusMeshBuilder</a></b> for a mesh of a torus.</li>
</ul>
<p>The following code snippet demonstrates how to create a 100x100 tensor product mesh of triangles:</p>
<div class="fragment"><div class="line"><span class="comment">// Create a LehrFEM++ square tensor product mesh</span></div>
<div class="line"><a class="code hl_class" href="classlf_1_1mesh_1_1utils_1_1_t_p_triag_mesh_builder.html">lf::mesh::utils::TPTriagMeshBuilder</a> builder(</div>
<div class="line">    std::make_unique&lt;lf::mesh::hybrid2d::MeshFactory&gt;(2));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set mesh parameters following the builder pattern</span></div>
<div class="line"><span class="comment">// Domain is the unit square</span></div>
<div class="line">builder.setBottomLeftCorner(Eigen::Vector2d{0, 0})</div>
<div class="line">    .setTopRightCorner(Eigen::Vector2d{99, 99})</div>
<div class="line">    .setNumXCells(100)</div>
<div class="line">    .setNumYCells(100);</div>
<div class="line"> </div>
<div class="line">std::shared_ptr&lt;lf::mesh::Mesh&gt; mesh_p = builder.Build();</div>
<div class="ttc" id="aclasslf_1_1mesh_1_1utils_1_1_t_p_triag_mesh_builder_html"><div class="ttname"><a href="classlf_1_1mesh_1_1utils_1_1_t_p_triag_mesh_builder.html">lf::mesh::utils::TPTriagMeshBuilder</a></div><div class="ttdoc">Implements a MeshBuilder that generates a triangular structured mesh.</div><div class="ttdef"><b>Definition</b> <a href="tp__triag__mesh__builder_8h_source.html#l00025">tp_triag_mesh_builder.h:25</a></div></div>
</div><!-- fragment --><div class="section_buttons"></div><div class="section_buttons"><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Previous   </th><th class="markdownTableHeadRight">Next    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyRight"><a class="el" href="quick_reference_geometry.html">Geometry</a>   </td></tr>
</table>
</div><div class="section_buttons"></div> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
